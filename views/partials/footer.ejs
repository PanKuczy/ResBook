<footer>
    footer-sruter
</footer>

<script>
// TOGGLE RESOURCE
// forceDirection can have "up" or "down" values
function toggleResource(id, forceDirection) {
        // console.log("Clicked ID: ", id);
        const rollout = document.getElementById("notesbox-" + id);
        let icon = document.getElementById('toggle-notes-icon-' + id);
        // check forced direction
        if (!forceDirection) {
            if (icon.classList.value === 'fa-solid fa-circle-chevron-down') {
                icon.classList.value = 'fa-solid fa-circle-chevron-up';
            } else {
                icon.classList.value = 'fa-solid fa-circle-chevron-down';
            }

            // console.log(rollout.classList);
            if (rollout.classList.value == "notes-box hidden" || rollout.classList.value === '') {
                rollout.classList.remove("hidden");
                rollout.classList.add("visible");
            } else {
                rollout.classList.add("hidden");
                rollout.classList.remove("visible");
            }
        } else if (forceDirection === "down") {
            icon.classList.value = 'fa-solid fa-circle-chevron-up';
            rollout.classList.remove("hidden");
            rollout.classList.add("visible");
        } else if (forceDirection === "up") {
            icon.classList.value = 'fa-solid fa-circle-chevron-down';
            rollout.classList.add("hidden");
            rollout.classList.remove("visible");
        }
    }



// ONCLICKS ale tylko niektore. te submity chyba beda do wywalenia - sprawdzic.

    function handler(id) {
        console.log(id);
        document.getElementById("add-" + id).classList.remove("hidden")
        document.getElementById("add-" + id).classList.add("visible")
        // document.getElementById("title" + id).setAttribute("hidden", true)
        // document.getElementById("edit" + id).setAttribute("hidden", true)
        // document.getElementById("done" + id).removeAttribute("hidden")
        // document.getElementById("input" + id).removeAttribute("hidden")
    }

// FILTERING RESOURCES BASIC FUNCTIONS
    let filtered = false;
    // const frontEndResources = <%-// JSON.stringify(resources) %>; //to chyba jednak nie bedzie potrzbene jak i cale zbieranie zasobow. niech ta funkcja opreuje tylko na DOM id'sach

    let filteredResourcesIds = [];
    let filteredResourcesDomIds = [];

    // zebranie wszystkich ksiazek
    const userBooks = document.getElementsByClassName('user-book');
    // zebranie DOMid wszystkich ksiazek
    let userBooksDomIds = [];
    for (let book of userBooks) {
        userBooksDomIds.push(book.id);
    };
    // console.log("User books DOM IDs: ", userBooksDomIds);
    filteredResourcesDomIds = [...userBooksDomIds];
    // console.log("filteredResourcesDomIds: ", filteredResourcesDomIds);

    function filterResources(add, remove, isolate) {
        // console.log("filtrowanie: ", add, remove, isolate);

        if (isolate) {
            filteredResourcesDomIds = [`resource-id-${isolate}`];
            toggleResource(isolate, "down");

            } else if(add) {
                const newId = `resource-id-${add}`;
                if (!filteredResourcesDomIds.includes(newId)) {
                    filteredResourcesDomIds.push(newId); // Only add if it doesn't exist already
                }
            } else if(remove) {
                const indexToRemove = filteredResourcesDomIds.indexOf(`resource-id-${remove}`);
                // console.log("Remove item index: ", indexToRemove);
                if (indexToRemove !== -1) {
                    filteredResourcesDomIds.splice(indexToRemove, 1);
                    // console.log("filteredResourcesDomIds: ", filteredResourcesDomIds);
                }
            }

        let booksToHide = userBooksDomIds.filter(domId => {
            return !filteredResourcesDomIds.includes(domId);
        });
        console.log("Books DOM IDs to hide: ", booksToHide);
        for (let bookId of booksToHide) {
            document.getElementById(bookId).classList.add("hidden")
            document.getElementById(bookId).classList.remove("visible")
        }
    }



// ADD NEW NOTE
    // Submit or cancel new note form
    function cancel(id){
        document.getElementById(id).classList.add("hidden")
        document.getElementById(id).classList.remove("visible")
    }
    function submit(id){
        document.getElementById(id).classList.add("hidden")
        document.getElementById(id).classList.remove("visible")
    }

    // Resize text areas automatically
    const textareas = document.getElementsByClassName('new-note-text');
    for (let element of textareas) {
        element.addEventListener('input', function() {
            // Reset the height to allow shrinking if necessary
            this.style.height = 'auto';
            // Set the new height based on the scroll height
            this.style.height = (this.scrollHeight) + 'px';
        });
    };


    // FUNCTION TO ADD TAGS TO NOTE --- chyba na razie nie używam i trzeba będzie jakoś zmienić

    let selectedTagIds = [];

    function newNoteRolloutToggle(id) {
        // event.preventDefault(); // Prevent default form submission - chyba przeszkadzalo
        const rollout = document.getElementById('tag-rollout-' + id);
        // change icon
        let triangle = document.getElementById('triangle-icon-' + id);
        if (triangle.classList.value === 'fa-solid fa-square-caret-right') {
            triangle.classList.value = 'fa-solid fa-square-caret-down';
        } else {
            triangle.classList.value = 'fa-solid fa-square-caret-right';
        }

        // Toggle tags rollouts
        if (rollout.classList.value == "tag-rollout-drawer hidden" || rollout.classList.value === '') {
            rollout.classList.remove("hidden");
            rollout.classList.add("visible");
        } else {
            rollout.classList.add("hidden");
            rollout.classList.remove("visible");
        }

    }

    function selectTag(element, resourceId) {
        const tagId = element.getAttribute('data-id');
        if (selectedTagIds.includes(tagId)) {
            selectedTagIds = selectedTagIds.filter(id => id !== tagId);
            element.classList.remove('clicked');
        } else {
            selectedTagIds.push(tagId);
            element.classList.add('clicked');
        }
        document.getElementById('selectedNewNoteTags-' + resourceId).value = selectedTagIds.join(',');
    }

    // ta funkcja jeszcze nie testowana i nie dziala
    function addTag() {
        const newTagInput = document.getElementById('new-tag');
        const newTagName = newTagInput.value.trim();
        if (newTagName) {
            const newTagId = new Date().getTime(); // Generate a unique ID for the new tag
            const tagContainer = document.getElementById('tag-container');
            
            const newTagElement = document.createElement('span');
            newTagElement.className = 'tag single-note-tags';
            newTagElement.setAttribute('data-id', newTagId);
            newTagElement.textContent = newTagName;
            newTagElement.onclick = function() { selectTag(this); };
            
            tagContainer.appendChild(newTagElement);
            
            newTagInput.value = ''; // Clear the input box
        }
    }


</script>

<!-- +++++++++++++++++++ NOWE FUNKCJE NON-RELOADING Z UZYCIEM AXIOS I RES.JSON, docelowo zastąpią większość routów z form i submit buttonow-->
<script>
    // Function to show confirmation popup and set the item ID, route, resource_id, type
    function showConfirmationPopup(itemId, route, resourceId, itemDOMid) {
        // Set the hidden item_id for deletion in the form dynamically
        document.querySelector('input[name="delete_item_id"]').value = itemId;
        // Set the hidden item_type for deletion in the form dynamically
        document.querySelector('input[name="delete_item_DOMid"]').value = itemDOMid;
        // Set the hidden resource_id for the item in the form dynamically
        document.querySelector('input[name="delete_resource_id"]').value = resourceId;
        // Set the action (route) dynamically
        // document.getElementById('delete-form').action = route;
        document.querySelector('input[name="delete_route"]').value = route;
        // Show the confirmation popup
        document.getElementById('confirmation-popup').style.display = 'flex';
    }

// Function to handle cancellation
function cancelDelete() {
    // Hide the confirmation popup without submitting the form
    document.getElementById('confirmation-popup').style.display = 'none';
}

// Delete Item (DELETE request using Axios)
// Function to handle deletion when user confirms
function confirmDelete() {
    // Hide the confirmation popup
    document.getElementById('confirmation-popup').style.display = 'none';

    const itemDomId = document.getElementById('delete-form').delete_item_DOMid.value;
    const itemElement = document.getElementById(itemDomId);
    const itemId = document.getElementById('delete-form').delete_item_id.value;
    const itemResourceId = document.getElementById('delete-form').delete_resource_id.value;
    const route = document.getElementById('delete-form').delete_route.value;
    // Adding a fade-out class for animation
    itemElement.classList.add('fade-out');
    // console.log("FE Delete request sent: ", itemDomId, itemId, itemResourceId, route);
    
    // do data bedzie mozna dodawac kolejne opcje jezeli beda potrzebne, np. note_id przy kasowaniu tagow
    const data = {
        resource_id: itemResourceId, 
        item_id: itemId
    };

    // After the animation, make the DELETE request
    setTimeout(() => {
        axios.post(route, data)
        .then(response => {
        if (response.data.success) {
            // Remove the item from the DOM
            itemElement.remove();
        }
        })
        .catch(error => {
        console.error('Error deleting item:', error);
        alert('Error deleting item');
        });
    }, 300); // Wait for animation to complete before sending DELETE request
}




</script>

</body>
</html>