<footer>
    footer-sruter
</footer>

<script>

// AUTO FIT INPUT ON PAGE LOAD
    document.addEventListener('DOMContentLoaded', () => {
        document.querySelectorAll('input.editable').forEach(input => {
            input.size = input.value.length;
        });
    });

// URL BUTTONS
    function urlButton (button) {
        console.log(button.getAttribute('data-url'));
        const targetUrl = button.getAttribute('data-url');
        const newWindow = window.open(targetUrl, '_blank', 'noopener,noreferrer');
        if (newWindow) {
        newWindow.opener = null;
        }
    }

// COLOR PICKER AND INVERTER
    let colorPickerInverted = "red";
    function colorPickerData(data) {
    const color = data.toRGBString();
    const currentButton = data.previewElement;
    // console.log(data);
    // console.log(data.previewElement);
    // console.log("Base color", color);
    const invertedColor = invertColor(color);
    // console.log("Inverted color: ", invertedColor);
    colorPickerInverted = invertedColor;
    if (currentButton.classList.contains('color-selector-button')) {
        currentButton.style.color = colorPickerInverted;
        currentButton.style.borderColor = colorPickerInverted;
    } else if (currentButton.classList.contains('color-selector-icon')){
        const parentDiv = currentButton.parentNode
        const childInput = parentDiv.querySelector('input');
        // console.log(currentButton.parentNode);
        parentDiv.setAttribute('data-color', color);
        parentDiv.setAttribute('data-invert-color', color);
        parentDiv.style.color = invertedColor;
        parentDiv.style.backgroundColor = color;
        parentDiv.style.borderColor = invertedColor;
        if (parentDiv.style.boxShadow) {
            // console.log(parentDiv.style.boxShadow);
            parentDiv.style.boxShadow = `${color} 0px 0px 0px 4px`
        }
        childInput.style.color = invertedColor;
        childInput.style.backgroundColor = color;

    }

    return invertedColor;
}

    function invertColor (color) {
    const regex = /rgb\((\d+),\s*(\d+),\s*(\d+)\)/;
    const result = color.match(regex);
    let invertColor = "";
    if (result) {
        const colorSum = parseInt(result[1], 10) + parseInt(result[2], 10) + parseInt(result[3], 10);
        if (colorSum>382){
            invertColor =  `hsl(from ${color} h calc(s + 15) calc(l - 35))`;
            return invertColor;
        } else {
            invertColor =  `hsl(from ${color} h 100 calc(l + 35))`;
            return invertColor;
        }
    } else {
        throw new Error("Invalid RGB string");
    }
}

// SORT

    function sortCategoriesList(){
        //non ediatble list
        const nonEditList = document.querySelector('#categories-list');

        [...nonEditList.children]
        .sort((a, b) => a.innerText.localeCompare(b.innerText, undefined, {sensitivity: 'base'}))
        .forEach(node => nonEditList.appendChild(node));

        //editable list
        const editableList = document.querySelector('#categories-list-editable');

        [...editableList.children]
        .sort((a, b) => a.querySelector('li').getAttribute('data-name').localeCompare(b.querySelector('li').getAttribute('data-name'), undefined, {sensitivity: 'base'}))
        .forEach(node => editableList.appendChild(node));

        //resourceheadings
        const resourceHeadings = document.getElementsByClassName('resource-categories-row');
        for (const item of resourceHeadings) {
            [...item.children]
            .sort((a, b) => a.innerText.localeCompare(b.innerText, undefined, {sensitivity: 'base'}))
            .forEach(node => item.appendChild(node));
            }

    }

    let currentResourcesSort = undefined;
    function sortResources(order){
        const parent = document.querySelector('.main-inner-box');
        const resources = document.querySelectorAll('.user-resource');

        switch (order) {
            case 'authors-asc':
                [...resources]
                .sort((a, b) => a.querySelector('.authors-content').innerText.localeCompare(b.querySelector('.authors-content').innerText, undefined, {sensitivity: 'base'}))
                .forEach(node => parent.appendChild(node));
                currentResourcesSort = order;
                break;
            case 'authors-desc':
                [...resources]
                .sort((b, a) => a.querySelector('.authors-content').innerText.localeCompare(b.querySelector('.authors-content').innerText, undefined, {sensitivity: 'base'}))
                .forEach(node => parent.appendChild(node));
                currentResourcesSort = order;
                break;
            case 'title-asc':
                [...resources]
                .sort((a, b) => a.querySelector('.resource-title').innerText.localeCompare(b.querySelector('.resource-title').innerText, undefined, {sensitivity: 'base'}))
                .forEach(node => parent.appendChild(node));
                currentResourcesSort = order; 
                break;
            case 'title-desc':
                [...resources]
                .sort((b, a) => a.querySelector('.resource-title').innerText.localeCompare(b.querySelector('.resource-title').innerText, undefined, {sensitivity: 'base'}))
                .forEach(node => parent.appendChild(node));
                currentResourcesSort = order; 
                break;
            case 'subtitle-asc':
                [...resources]
                .sort((a, b) => a.querySelector('.resource-subtitle').innerText.localeCompare(b.querySelector('.resource-subtitle').innerText, undefined, {sensitivity: 'base'}))
                .forEach(node => parent.appendChild(node));
                currentResourcesSort = order; 
                break;
            case 'subtitle-desc':
                [...resources]
                .sort((b, a) => a.querySelector('.resource-subtitle').innerText.localeCompare(b.querySelector('.resource-subtitle').innerText, undefined, {sensitivity: 'base'}))
                .forEach(node => parent.appendChild(node));
                currentResourcesSort = order; 
                break;
            case 'published-date-asc':
                [...resources]
                .sort((a, b) => a.querySelector('.year-text').innerText.localeCompare(b.querySelector('.year-text').innerText, undefined, {sensitivity: 'base'}))
                .forEach(node => parent.appendChild(node));
                currentResourcesSort = order; 
                break;
            case 'published-date-desc':
                [...resources]
                .sort((b, a) => a.querySelector('.year-text').innerText.localeCompare(b.querySelector('.year-text').innerText, undefined, {sensitivity: 'base'}))
                .forEach(node => parent.appendChild(node));
                currentResourcesSort = order; 
                break;
            case 'added-date-asc':
                [...resources]
                .sort((a, b) => a.getAttribute('data-created-date').localeCompare(b.getAttribute('data-created-date'), undefined, {sensitivity: 'base'}))
                .forEach(node => parent.appendChild(node));
                currentResourcesSort = order; 
                break;
            case 'added-date-desc':
                [...resources]
                .sort((b, a) => a.getAttribute('data-created-date').localeCompare(b.getAttribute('data-created-date'), undefined, {sensitivity: 'base'}))
                .forEach(node => parent.appendChild(node));
                currentResourcesSort = order; 
                break;
            case 'place-asc':
                [...resources]
                .sort((a, b) => a.querySelector('.place-text').innerText.localeCompare(b.querySelector('.place-text').innerText, undefined, {sensitivity: 'base'}))
                .forEach(node => parent.appendChild(node));
                currentResourcesSort = order; 
                break;
            case 'place-desc':
                [...resources]
                .sort((b, a) => a.querySelector('.place-text').innerText.localeCompare(b.querySelector('.place-text').innerText, undefined, {sensitivity: 'base'}))
                .forEach(node => parent.appendChild(node));
                currentResourcesSort = order; 
                break;
            default:
                break;
        }
        console.log("Current resource sort: ", currentResourcesSort);
    };

    function sortTagsRow(parent){
        let range = undefined;
        if (!parent) {
            range = document;
        } else {
            range = parent;
        }
        // non editable list
        const nonEditLists = range.querySelectorAll('.all-tags-row, .note-tags-row');
        const editLists = range.querySelectorAll('.edit-tags-form > .all-tags-row , .edit-tags-form > .note-tags-row ');
        nonEditLists.forEach(tagsRowContainer =>{
            [...tagsRowContainer.children]
            .sort((a, b) => a.innerText.localeCompare(b.innerText, undefined, {sensitivity: 'base'}))
            .forEach(node => tagsRowContainer.appendChild(node));
        });

        editLists.forEach(tagsRowContainer =>{
            [...tagsRowContainer.children]
            .sort((a, b) => a.getAttribute('data-name').localeCompare(b.getAttribute('data-name'), undefined, {sensitivity: 'base'}))
            .forEach(node => tagsRowContainer.appendChild(node));
            // [...tagsRowContainer.children].forEach(el => {
            //     console.log("Element item" ,el, el.getAttribute('data-name'));
            // })
        });

    }


    function sortNotesToggle(order, singleResource){
        // trzeba jeszcze dodac togglowanie przy klikaniu ikony ze strzalka lub wyborze z listy
        const notesBoxes = singleResource?.getElementsByClassName('notes-box') ?? document.getElementsByClassName('notes-box');

        if (order == 'date-ascending') {
            for (const item of notesBoxes) {
            [...item.querySelectorAll('.single-note-item')]
            .sort((a, b) => a.querySelector('.note-date').innerText.localeCompare(b.querySelector('.note-date').innerText, undefined, {sensitivity: 'base'}))
            .forEach(node => item.appendChild(node));
            }
        } else {
            for (const item of notesBoxes) {
            [...item.querySelectorAll('.single-note-item')]
            .sort((b, a) => a.querySelector('.note-date').innerText.localeCompare(b.querySelector('.note-date').innerText, undefined, {sensitivity: 'base'}))
            .forEach(node => item.appendChild(node));
            }   
        }

    }
    //call sorting on page load
    sortCategoriesList();
    sortResources('added-date-desc');
    sortNotesToggle('date-descending', null);
    sortTagsRow();


// FORM TO OBJECT CONVERT - REUSABLE FUNCTION
    function formToObject(formDomId){
        const form = document.getElementById(formDomId);
        // Create a FormData object from the form
        const formData = new FormData(form);
        // Convert FormData to a plain object (or you can directly send FormData)
        const formObjectData = {};
        formData.forEach((value, key) => {
            formObjectData[key] = value;
        });
        return formObjectData;
    }

// TOGGLE RESOURCE
// forceDirection can have "up" or "down" values
    function toggleResource(id, forceDirection) {
        // console.log("Clicked ID: ", id);
        const rollout = document.getElementById("notesbox-" + id);
        const stripe = document.querySelector(`#resource-id-${id} .right-stripe`);
        let icon = document.getElementById('toggle-notes-icon-' + id);
        // check forced direction
        if (!forceDirection) {
            if (icon.classList.value === 'fa-solid fa-circle-chevron-down') {
                icon.classList.value = 'fa-solid fa-circle-chevron-up';
            } else {
                icon.classList.value = 'fa-solid fa-circle-chevron-down';
            }

            // console.log(rollout.classList);
            if (rollout.classList.value == "notes-box hidden" || rollout.classList.value === '') {
                rollout.classList.remove("hidden");
                rollout.classList.add("visible");
                stripe.classList.add('border-bottom-5');
            } else {
                rollout.classList.add("hidden");
                rollout.classList.remove("visible");
                stripe.classList.remove('border-bottom-5');
            }
        } else if (forceDirection === "down") {
            icon.classList.value = 'fa-solid fa-circle-chevron-up';
            rollout.classList.remove("hidden");
            rollout.classList.add("visible");
            stripe.classList.add('border-bottom-5');
        } else if (forceDirection === "up") {
            icon.classList.value = 'fa-solid fa-circle-chevron-down';
            rollout.classList.add("hidden");
            rollout.classList.remove("visible");
            stripe.classList.remove('border-bottom-5');
        }
    }


// FILTERING RESOURCES BASIC FUNCTIONS
    let filtered = false;
    // const frontEndResources = <%-// JSON.stringify(resources) %>; //to chyba jednak nie bedzie potrzbene jak i cale zbieranie zasobow. niech ta funkcja opreuje tylko na DOM id'sach

    let filteredResourcesIds = [];
    let filteredResourcesDomIds = [];

    // zebranie wszystkich ksiazek
    const userResources = document.getElementsByClassName('user-resource');
    // zebranie DOMid wszystkich ksiazek
    let userResourcesDomIds = [];
    for (let resource of userResources) {
        userResourcesDomIds.push(resource.id);
    };
    // console.log("User resources DOM IDs: ", userResourcesDomIds);
    filteredResourcesDomIds = [...userResourcesDomIds];
    // console.log("filteredResourcesDomIds: ", filteredResourcesDomIds);

    function filterResources(add, remove, isolate) {
        // console.log("filtrowanie: ", add, remove, isolate);

        if (isolate) {
            filteredResourcesDomIds = [`resource-id-${isolate}`];
            toggleResource(isolate, "down");

            } else if(add) {
                const newId = `resource-id-${add}`;
                if (!filteredResourcesDomIds.includes(newId)) {
                    filteredResourcesDomIds.push(newId); // Only add if it doesn't exist already
                }
            } else if(remove) {
                const indexToRemove = filteredResourcesDomIds.indexOf(`resource-id-${remove}`);
                // console.log("Remove item index: ", indexToRemove);
                if (indexToRemove !== -1) {
                    filteredResourcesDomIds.splice(indexToRemove, 1);
                    // console.log("filteredResourcesDomIds: ", filteredResourcesDomIds);
                }
            }

        let resourcesToHide = userResourcesDomIds.filter(domId => {
            return !filteredResourcesDomIds.includes(domId);
        });
        // console.log("Resources DOM IDs to hide: ", resourcesToHide);
        for (let resourceId of resourcesToHide) {
            document.getElementById(resourceId).classList.add("hidden")
            document.getElementById(resourceId).classList.remove("visible")
        }
    }



// FILTER BY CATEGORY
    // na razie skopiowana na chama z tagsow
    let selectedCatIds = [];
    let selectedCatNames = [];

    function selectCategory(element, resourceId) {
        const catId = element.getAttribute('data-id');
        const catName = element.getAttribute('data-name');

        //Ids
        if (selectedCatIds.includes(catId)) {
            selectedCatIds = selectedCatIds.filter(id => id !== catId);
            element.classList.remove('clicked');
        } else {
            selectedCatIds.push(catId);
            element.classList.add('clicked');
        }
        //Names
        if (selectedCatNames.includes(catName)) {
            selectedCatNames = selectedCatNames.filter(name => name !== catName);
        } else {
            selectedCatNames.push(catName);
        }

        //tu dalej powinna byc funkcja filtrujaca

        // document.getElementById('selectedNewNoteCats-' + resourceId).value = selectedCatIds.join(',');
        // document.getElementById('selectedNewNoteCatsNames-' + resourceId).value = selectedCatNames.join(',');
    }


// ADD NEW CATEGORY
    function addNewCategory(formId) {
        // Prevent default form submission
        event.preventDefault();
        const form = document.getElementById(formId);
        const formObject = formToObject(formId);

        // Check if the input is not empty
        if (!formObject.newCategoryName) {
            return false;
        } else {
            // axios route
            axios.post('/add-category', formObject)
                .then((response) => {
                    // console.log("Response :" , response.data);
                    if (response.data.success) {
                        const newCategoryResponse = response.data.newCategory;
                        // console.log("Response data :", response.data);
                        // CREATE DOM ELEMENTS
                        // non editable list
                        let newCategoryElement = document.createElement('li');
                        newCategoryElement.classList.add('categories-item');
                        newCategoryElement.setAttribute('id', `category-id-${newCategoryResponse.id}`);
                        newCategoryElement.setAttribute('draggable', 'true');
                        newCategoryElement.setAttribute('data-id', `${newCategoryResponse.id}`); 
                        newCategoryElement.setAttribute('data-name', `${formObject.newCategoryName}`); 
                        newCategoryElement.setAttribute('onclick', `selectCategory(this, ${newCategoryResponse.id})`); 
                        newCategoryElement.innerHTML = formObject.newCategoryName;
                        document.getElementById('categories-list').appendChild(newCategoryElement);
                        // editable list
                        let newCategoryEditableElement = document.createElement('div');
                        newCategoryEditableElement.classList.add('deletable-item', 'visible');
                        newCategoryEditableElement.setAttribute('id', `editable-category-row-${newCategoryResponse.id}`);

                        newCategoryEditableElement.innerHTML = `
                        <button 
                        class="icon-button tooltip-container" 
                        id="delete-category-${newCategoryResponse.id}"
                        type="button"
                        onclick="showConfirmationPopup('${newCategoryResponse.id}', '/delete-category', null, 'editable-category-row-${newCategoryResponse.id}', 'category-id-${newCategoryResponse.id}')">
                        <i class="fa-solid fa-trash"></i><span class="tooltip">delete category</span>
                        </button><li class="categories-item" data-id="${newCategoryResponse.id}" data-name="${formObject.newCategoryName}" ><input type="text" id="editable-category-${newCategoryResponse.id}" value="${formObject.newCategoryName}" required></li>
                        `;
                        document.getElementById('categories-list-editable').appendChild(newCategoryEditableElement);
                        catDraggable([newCategoryElement]);
                        form.reset();
                        sortCategoriesList()
                    } else {
                        alert('Error adding category (response).');
                    }
  
                })
                .catch((error) => {
                    console.error('Error adding category:', error);
                    alert('Error adding category (catch).');
                });

        }
    }

// EDIT CATEGORIES
    // Buttons toggle
    function editCategoriesToggle(){
        let categoriesListDisplay = document.getElementById('categories-list').style.display;
        let form = document.getElementById('edit-categories-form');
        // let categoriesEditListDisplay = document.getElementById('categories-list-editable').style.display;
        if (categoriesListDisplay == 'block') {
            document.getElementById('categories-list').style.display = 'none';
            document.getElementById('categories-list-editable').style.display = 'block'
            document.getElementById('edit-categories-submit-button').removeAttribute('disabled');
            document.getElementById('edit-categories-cancel-button').removeAttribute('disabled');
        } else {
            document.getElementById('categories-list').style.display = 'block';
            document.getElementById('categories-list-editable').style.display = 'none'
            document.getElementById('edit-categories-submit-button').disabled ='true';
            document.getElementById('edit-categories-cancel-button').disabled ='true';
            form.reset();
        }
    }


    // EDIT CATEGORIES
    function editCategoriesSubmit(formId){
        // Prevent default form submission
        event.preventDefault();

        // Get the form element
        // const form = document.getElementById(formId); chyba niepotrzbene juz
        // Get data from inputs, collect items to change
        const editableList = document.getElementById('categories-list-editable');
        const editableListItems = editableList.querySelectorAll('li.categories-item');

        // console.log(editableListItems);
        let formObject = [];
        editableListItems.forEach(cat => {
            formObject.push({
                id: cat.getAttribute('data-id'),
                name: cat.querySelector('input').value
            });

        });
        // console.log("formObject array :", formObject);

        // Check if there are no empty inputs
        if (formObject.find((item) => item.name == "")) {
            alert("Invalid category name!")
            return false;
        } else {
            // axios route
            axios.put('/edit-categories', formObject)
                .then((response) => {
                    // console.log("Response :" , response.data);
                    if (response.data.success) {
                        const newCategoryResponse = response.data.newCategory;
                        // console.log("Response data :", response.data);

                        // UPDATE HTML ELEMENTS
                        formObject.forEach(formItem => {
                            // non editable categories list
                            const nonEditableListItem = document.getElementById('categories-list').querySelector(`li[data-id="${formItem.id}"]`);
                            if (nonEditableListItem) {
                                nonEditableListItem.setAttribute('data-name', formItem.name);
                                nonEditableListItem.innerHTML = formItem.name;
                            }
                            // editable categories list
                            const editableListItem = document.getElementById('categories-list-editable').querySelector(`li[data-id="${formItem.id}"]`);
                            if (editableListItem) {
                                editableListItem.setAttribute('data-name', formItem.name);
                                const inputElement = editableListItem.querySelector('input');
                                inputElement.setAttribute('value', formItem.name);
                            }
                            // resources
                            const resourcesCategories = document.getElementsByClassName(`resource-with-category-${formItem.id}`);
                            if (resourcesCategories) {
                                for (const classInstance of resourcesCategories) {
                                    classInstance.innerHTML = formItem.name;
                                }
                            }
                        });

                        sortCategoriesList()
                        // toggle back the buttons
                        
                        editCategoriesToggle()

                    } else {
                        alert('Error updating categories (response).');
                    }
  
                })
                .catch((error) => {
                    console.error('Error updating categories:', error);
                    alert('Error updating categories (catch).');
                });
        }
    }


// ADD NEW RESOURCE
    function createNewResourceToggle(){
        const newResPopup = document.querySelector('#new-resource-popup');
        if (newResPopup.style.display == 'none') {
            newResPopup.style.display = 'flex';
            newResPopup.style.pointerEvents = 'auto';
        } else {
            const inputs = newResPopup.querySelectorAll('input:not([name="res-type"]), textarea');
            inputs.forEach(item => {
                item.value = "";
            });
            newResPopup.querySelector('img').setAttribute('src', '');
            newResPopup.querySelector('img').setAttribute('upload-flag', false);
            newResPopup.querySelectorAll('.resource-type-row input').forEach(item => {
                item.checked = false;
            }); 
            newResPopup.style.display = 'none';
            newResPopup.style.pointerEvents = 'none';
        }
    }

    async function getDataFromLibraries() {
        event.preventDefault();
        const newResPopup = document.querySelector('#new-resource-popup');
        const headingEdit = newResPopup.querySelector('.resource-heading.editable');
        //new data
        const newCover = headingEdit.querySelector('img');
        const newType = headingEdit.querySelector('input[name="res-type"]:checked');
        const newNumber = headingEdit.querySelector('#resource-new-isbn-doi');
        const newTitle = headingEdit.querySelector('.resource-title.editable textarea');
        const newSubtitle = headingEdit.querySelector('.resource-subtitle.editable textarea');
        const newJournal = headingEdit.querySelector('.resource-journal.editable textarea');
        const newAuthors = headingEdit.querySelector('.author-text.editable textarea');
        const newYear = headingEdit.querySelector('.year-text.editable input');
        const newPlace = headingEdit.querySelector('.place-text.editable input');
        const newUrl = headingEdit.querySelector('.url-text.editable input');


        // ISBN przykladowe 9781800643451
        // ISBN przykladowe 0860547051
        // ISBN przykladowe 9788323540991
        // DOI przykladowe 10.1594/PANGAEA.726855
        // DOI przykladowe 10.5604/01.3001.0013.2010
        // DOI przykladowe 10.1016/j.ancene.2014.05.003
        if (!newNumber.value || !newType) {
            alert("choose resource type and ISBN number");
            return false;
        } else {
            let fetchedData = undefined;
            //check if ISBN or DOI
            if (newType.value == 'ISBN') {
                const queryUrl = `https://openlibrary.org/api/books?bibkeys=${newType.value}:${newNumber.value}&jscmd=data&format=json`;
                // console.log("query url: ", queryUrl);
                try {
                    // console.log("fetching...");
                    const getBookOL = await axios.get(queryUrl);
                    const resultSubData = getBookOL.data[`${newType.value}:${newNumber.value}`];
                    if (resultSubData) {
                        // console.log("response: ", resultSubData);
                        fetchedData = {
                            title: resultSubData?.title,
                            subtitle: resultSubData?.subtitle ?? null,
                            journal: null,
                            publication_year: resultSubData?.publish_date ?? null,
                            place: resultSubData?.publish_places?.[0]?.name ?? null,
                            cover_url: resultSubData?.cover?.medium ?? null,
                            // url: resultSubData?.url,
                            url: "https://openlibrary.org" + resultSubData?.key + "/-/borrow?action=locate"

                        };
                        let authorsArray = [];
                        for (let i = 0; i < resultSubData?.authors.length; i++) {
                            authorsArray.push(resultSubData?.authors[i].name);
                            if (i===3){
                                authorsArray[3] = "et. al";
                                break
                            }
                        }
                        fetchedData.authors = authorsArray.join(", ");
                        // console.log(fetchedData);
                    } else {
                        alert("resource not found");
                    }
                } catch (error) {
                    console.log(error);
                    alert(error);
                }
            } else if (newType.value == 'DOI') {
                const queryUrl = `https://api.crossref.org/works/${newNumber.value}`;
                try {
                    console.log("fetching...");
                    const getCrossrefOrg = await axios.get(queryUrl);
                    console.log("result data ", getCrossrefOrg.data.message);
                    const resultSubData = getCrossrefOrg.data.message;
                    const date = resultSubData?.published["date-parts"][0];
                    const dateJoined = date.join("-");
                    console.log(dateJoined);
                    if (getCrossrefOrg.status = 200) {
                        console.log("response: ", resultSubData);
                        fetchedData = {
                            title: resultSubData?.title[0] ?? null,
                            subtitle: resultSubData?.subtitle[0] ?? null,
                            publication_year: resultSubData?.published["date-parts"]?.[0].join('-') ?? null,
                            place: null,
                            cover_url: null,
                            url: resultSubData?.URL
                        };
                        let authorsArray = [];
                        for (let i = 0; i < resultSubData?.author.length; i++) {
                            authorsArray.push(resultSubData?.author[i].family + " " + resultSubData?.author[i].given);
                            if (i===3){
                                authorsArray[3] = "et. al";
                                break
                            }
                        }
                        fetchedData.authors = authorsArray.join(", ");
                        let journalArray = [];
                        if (resultSubData?.["container-title"]?.[0]) {
                            journalArray.push(resultSubData?.["container-title"]?.[0]);
                        }
                        if (resultSubData?.volume) {
                            journalArray.push(resultSubData?.volume);
                        }
                        if (resultSubData?.["journal-issue"]?.issue) {
                            journalArray.push(resultSubData?.["journal-issue"]?.issue);
                        }
                        fetchedData.journal = journalArray.join(" / ");
                        console.log(fetchedData);
                    } else {
                        alert("resource not found");
                    }
                } catch (error) {
                    console.log(error);
                    alert(error);
                }
            }
            //dom operations
            if (fetchedData) {
                newTitle.value = fetchedData.title;
                newSubtitle.value = fetchedData.subtitle;
                newJournal.value = fetchedData.journal;
                newYear.value = fetchedData.publication_year;
                newPlace.value = fetchedData.place;
                newAuthors.value = fetchedData.authors;
                newUrl.value = fetchedData.url;
                newCover.setAttribute('src', fetchedData.cover_url ?? '');
            }
        }
    }

    function submitNewResource() {
        const newResPopup = document.querySelector('#new-resource-popup');
        const headingEdit = newResPopup.querySelector('.resource-heading.editable');
        //new data
        const newCover = headingEdit.querySelector('img');
        const newType = headingEdit.querySelector('input[name="res-type"]:checked');
        const newNumber = headingEdit.querySelector('#resource-new-isbn-doi');
        const newTitle = headingEdit.querySelector('.resource-title.editable textarea');
        const newSubtitle = headingEdit.querySelector('.resource-subtitle.editable textarea');
        const newJournal = headingEdit.querySelector('.resource-journal.editable textarea');
        const newAuthors = headingEdit.querySelector('.author-text.editable textarea');
        const newYear = headingEdit.querySelector('.year-text.editable input');
        const newPlace = headingEdit.querySelector('.place-text.editable input');
        const newUrl = headingEdit.querySelector('.url-text.editable input');

        //check if required fields are not empty
        if (!newTitle.value || !newAuthors.value || !newType) {
            alert("title, authors and resource type fields can't be empty");
            return false;
        } else {
            const data = {
                resource_title: newTitle.value,
                resource_subtitle: newSubtitle.value,
                journal: newJournal.value,
                authors: newAuthors.value,
                resource_type: newType.value,
                reference_number: newNumber.value,
                place: newPlace.value,
                publication_year: newYear.value,
                url: newUrl.value
            };
            if (newCover.getAttribute('upload-flag') == 'true'){
                data.cover_base64 = newCover.getAttribute('src');
            }
            // console.log(data);
            //axios
            axios.post("/new-resource", data)
            .then(response => {
                if (response.data.success) {
                    // console.log("create resource success", response.data);
                    const newId = response.data.resource_id;
                    const tags = response.data.tags;
                    const createdDate = response.data.formattedDate;
                    //DOM operations
                    const newResourceElement = document.createElement('div');
                    newResourceElement.classList.add('user-resource', 'deletable-item', 'hidden');
                    if (newType == 'ISBN') {
                        newResourceElement.classList.add('book');
                    } else if (newType == 'DOI'){
                        newResourceElement.classList.add('article');
                    }
                    newResourceElement.setAttribute('id', `resource-id-${newId}`);
                    newResourceElement.setAttribute('data-id', newId);
                    newResourceElement.setAttribute('data-type', newType.value);
                    newResourceElement.setAttribute('data-number', newNumber.value ?? null);
                    newResourceElement.setAttribute('data-created-date', createdDate);

                    newResourceElement.innerHTML =` 
                        <a class="resource-heading" style="display: flex;" onclick="filterResources(null, null, ${newId})">                            
                            <div class="resource-cover">
                                <img src="${newCover.getAttribute('src') ?? null }" draggable="false">
                            </div>
                            <div class="resource-heading-text">
                                <div class="resource-categories-row"> <!-- CATEGORIES -->
                                </div>         
                                <h2 class="resource-title">${newTitle.value}</h2>
                                <h3 class="resource-subtitle">${newSubtitle.value}</h3>
                                <div class="journal-group"><h3>${newJournal?.value ? 'In: ' : ''}</h3><h3 class="resource-journal">${newJournal.value}</h3></div>
                                <div class="resource-authors-date-place-row">
                                    <div class="authors-group"><h5 class="author-text">By </h5><h5 class="author-text authors-content">${newAuthors.value}</h5></div>
                                    <div class="date-place-group">
                                        <h5 class="year-text">${newYear?.value ?? ''}</h5>
                                        <h5 class="comma">${newYear.value && newPlace.value ? ',' : '' }</h5>
                                        <h5 class="place-text">${newPlace.value ?? ''}</h5>
                                    </div>
                                </div>
                            </div>
                            <div class="right-stripe ${newType.value == "ISBN" ? "book" : "article"}"></div>
                        </a>
                        <!-- editable -->
                        <form class="resource-heading editable" style="display: none;">
                            <div>
                                <div class="resource-cover editable">
                                    <img src="${newCover.getAttribute('src') ?? null }" draggable="false">
                                </div>
                                <input class="upload-cover custom-file-input" type="file" accept="image/*">
                            </div>
                            <div class="resource-heading-text">
                                <h2 class="resource-title editable">Title: <textarea rows="2">${newTitle.value}</textarea><h2>
                                <h3 class="resource-subtitle editable">Subtitle: <textarea rows="2">${newSubtitle.value}</textarea></h3>
                                <h3 class="resource-journal editable">Journal: <textarea rows="1">${newJournal?.value}</textarea></h3>
                                <div class="resource-authors-date-place-row">
                                    <div class="authors-group editable">
                                        <h5 class="author-text editable">Authors: <textarea rows="2">${newAuthors.value}</textarea></h5>
                                        <h5 class="url-text editable">Link: <input value="${newUrl.value}"></h5>
                                    </div>
                                    <div class="date-place-group editable">
                                        <div class="resource-type-row">
                                            <h5>Resource type: 
                                                    <input type="radio" name="res-type" value="ISBN" checked />
                                                    <label for="ISBN">Book</label>
                                                    <input type="radio" name="res-type" value="DOI" />
                                                    <label for="DOI">Article</label>
                                            </h5>
                                        </div>
                                        <h5 class="isbn-text editable">ISBN/DOI number:<input name="isbn-doi-number" id="resource-${newId}-isbn-doi" value="${newNumber.value}"></h5>  
                                        <h5 class="year-text editable">Year: <input value="${newYear.value}"></h5><h5 class="place-text editable">Place: <input value="${newPlace.value}"></h5>
                                    </div>
                                </div>
                            </div>
                            <div class="right-stripe"></div>
                        </form>

                        <div class="resource-heading-buttons">
                            <button 
                                class="icon-button tooltip-container edit-toggle-button" 
                                type="edit" 
                                name="edit-resource" 
                                onclick="editResourceToggle(this, ${newId})">
                                <i class="fa-solid fa-file-pen"></i><span class="tooltip">edit resource</span>
                            </button>
                            <button 
                                disabled
                                class="icon-button tooltip-container edit-submit-button"
                                type="button"
                                name="edit-resource-submit" 
                                onclick="editResourceToggle(this, ${newId})">
                                <i class="fa-solid fa-floppy-disk"></i><span class="tooltip">save changes</span>
                            </button>
                            <button 
                                disabled
                                class="icon-button tooltip-container edit-cancel-button" 
                                type="button" 
                                name="edit-resource-cancel" 
                                onclick="editResourceToggle(this, ${newId})">
                                <i class="fa-solid fa-rotate-left"></i><span class="tooltip">discard changes</span>
                            </button>
                            <button 
                                class="delete-button icon-button tooltip-container" 
                                id="delete-resource-${newId}"
                                type="button"
                                onclick="showConfirmationPopup(null, '/delete-resource', '${newId}', 'resource-id-${newId}', null)">
                                <i class="fa-solid fa-trash"></i><span class="tooltip">delete resource</span>
                            </button>
                            <button
                                ${newUrl?.value ? 'enabled' : 'disabled' }
                                class="url-button icon-button tooltip-container" 
                                id="resource-url-${newId}"
                                type="button"
                                data-url="${newUrl?.value ?? null}"
                                onclick="urlButton(this)">
                                <i class="fa-solid fa-up-right-from-square"></i><span class="tooltip">open link to the resource</span>
                            </button>
                        </div>
                        <div class="resource-expand">
                            <button class="icon-button" onclick="toggleResource(${newId})" type="button"><i id="toggle-notes-icon-${newId}" class="fa-solid fa-circle-chevron-down"></i></button>
                        </div>
                        <!-- NOTES     -->
                        <div class="notes-box hidden" id="notesbox-${newId}">
                            <div class="notes-box-heading">
                                <h4><span>Notes <span><button class="icon-button tooltip-container" type="add" name="add-note" onclick="newNoteRolloutToggle('${newId}')"><i class="fa-solid fa-square-plus"></i><span class="tooltip">create new note</span></button></span></span> <span class="notes-sortby">Sort by:</span></h4>
                        <!-- ADD NOTE -->
                                <form class="new-note hidden" action="/add-note" method="post" id="add-new-note-${newId}">
                                    <div class="new-note-box">
                                        <button class="new-note-tag-rollout-button" onclick="selectTagsRolloutToggle(this, ${newId}, null)" type="button">Select Tags <i id="triangle-icon-${newId}" class="fa-solid fa-square-caret-right"></i></button>
                                        <div id="tag-rollout-${newId}" class="tag-rollout-drawer hidden-fast">
                                            <div class="heading-with-buttons">
                                                <h4>Assign Note Tags:</h4>
                                                <div>
                                                    <button 
                                                    class="icon-button tooltip-container edit-tags-toggle-button" 
                                                    type="button"
                                                    name="edit-tags-toggle" 
                                                    onclick="editTagsToggle(${newId}, null)">
                                                    <i class="fa-solid fa-file-pen"></i><span class="tooltip">edit tags</span>
                                                    </button>
                                                    <button 
                                                    disabled
                                                    class="icon-button tooltip-container edit-tags-submit-button"
                                                    type="button"
                                                    name="edit-tags-submit" 
                                                    onclick="editTagsSubmit(this)">
                                                    <i class="fa-solid fa-floppy-disk"></i><span class="tooltip">save changes</span>
                                                    </button>
                                                    <button 
                                                    disabled
                                                    class="icon-button tooltip-container edit-tags-cancel-button" 
                                                    type="button" 
                                                    name="edit-tags-cancel" 
                                                    onclick="editTagsToggle(${newId}, null)">
                                                    <i class="fa-solid fa-rotate-left"></i><span class="tooltip">discard changes</span>
                                                    </button>
                                                </div>
                                            </div>
                                            <div class="separator-2"></div>
            
                                            <div id="tag-container-${newId}" class="all-tags-row" style="display: flex;">
                                            </div>
                                            <div class="edit-tags-form">
                                                <div id="edit-tag-container-${newId}" class="all-tags-row" style="display: none;">
                                                </div>
                                            </div>
                                            <div class="add-new-tag-miniform">
                                                <input class="add-new-tag-input" type="text" placeholder="New tag name..." />
                                                <button class="color-selector-button" data-jscolor="{value:'#5ED8FF'}" >color</button>
                                                <button class="text-button" type="button" onclick="addTag(${newId}, null)">Add New Tag</button>
                                            </div>
                                            <input type="hidden" name="selectedTagIds" id="selectedNewNoteTags-${newId}" />
                                            <input type="hidden" name="selectedTagsNames" id="selectedNewNoteTagsNames-${newId}" />
                                            <input type="hidden" name="selectedTagsColors" id="selectedNewNoteTagsColors-${newId}" />
                                            <input type="hidden" name="selectedTagsColorsInv" id="selectedNewNoteTagsColorsInv-${newId}" />
                                        </div>

                                        <textarea class="new-note-text" type="text" name="note_text" placeholder="New note..." autocomplete="off" autofocus="true" id="new-note-text-${newId}" required></textarea>
                                        <div class="flex-end">
                                            <label for="new-note-link">Link: </label>
                                            <input class="input-link" type="text" name="target_object" placeholder="Link" autocomplete="off" autofocus="true" id="new-note-link-${newId}"/>
                                            <label for="new-note-pages">Pages: </label>
                                            <input class="input-pages" type="text" name="target_pages" placeholder="Pages" autocomplete="off" autofocus="true" id="new-note-pages-${newId}"/>
        
                                        </div>
                                        <input type="hidden" name="resource_id" value="${newId}" />
                                        <button class="text-button" type="submit" name="note-submit" onclick="submitNewNote('add-new-note-${newId}')" value="" >Submit</button>
                                        <button class="text-button" type="reset" name="note-cancel" onclick="cancelNewNote('add-new-note-${newId}')" value="" >Cancel</button>
                                    </div>
                                </form>
                            </div>
                        </div>
                    `
                    if (newType.value == "ISBN") {
                        newResourceElement.querySelector('.date-place-group.editable input[value="ISBN"]').setAttribute('checked', true);
                    } else {
                        newResourceElement.querySelector('.date-place-group.editable input[value="DOI"]').setAttribute('checked', true);
                    }

                    //tags
                    const tagContainer = newResourceElement.querySelector(`#tag-container-${newId}`);
                    tags.forEach(tag => { 
                        const spanElement = document.createElement('span');
                        spanElement.classList.add('tag', 'single-note-tags', 'visible-horizontal');
                        spanElement.setAttribute('data-id', tag.id);
                        spanElement.setAttribute('data-name', tag.name);
                        spanElement.setAttribute('data-color', tag.color);
                        spanElement.setAttribute('data-invert-color', tag.invertColor);
                        spanElement.style.backgroundColor = tag.color;
                        spanElement.style.color = tag.invertColor;
                        spanElement.style.borderColor = tag.invertColor;
                        spanElement.setAttribute('onclick', `selectTag(this, ${newId})`);
                        spanElement.innerText = tag.name;
                        tagContainer.appendChild(spanElement);
                    });
                    const editTagContainer = newResourceElement.querySelector(`#edit-tag-container-${newId}`);
                    tags.forEach(tag => { 
                        const divElement = document.createElement('div');
                        divElement.classList.add('editable-tag-row', 'tag', 'single-note-tags', 'visible-horizontal');
                        divElement.setAttribute('data-id', tag.id);
                        divElement.setAttribute('data-name', tag.name);
                        divElement.setAttribute('data-color', tag.color);
                        divElement.setAttribute('data-invert-color', tag.invertColor);
                        divElement.style.backgroundColor = tag.color;
                        divElement.style.color = tag.invertColor;
                        divElement.style.borderColor = tag.invertColor;
                        divElement.setAttribute('onclick', `selectTag(this, ${newId})`);
                        divElement.innerHTML = `
                            <input type="text" oninput="this.size = this.value.length" class="tag editable" value="${tag.name}" style="background-color: ${tag.color}; color: ${tag.invertColor};" size="${tag.name.length}">
                            </input>
                            <button 
                            class="icon-button color-selector-icon tooltip-container tag-color-${tag.id}" 
                            data-jscolor="{value:'${tag.color}'}"
                            type="button">
                            <span class="tooltip">change color</span>
                            </button>
                            <button 
                            class="delete-button icon-button tooltip-container delete-tag-${tag.id}" 
                            type="button"
                            onclick="showConfirmationPopup('${tag.id}', '/delete-tag', ${newId}, null, null)">
                            <i class="fa-solid fa-trash"></i><span class="tooltip">delete tag</span>
                            </button>
                        `;
                        editTagContainer.appendChild(divElement);
                    });
                    
                    //dodac listenery do kategorii, js-color w rolloucie nowej notatki i edytowalnych tagow nowej notatki

                    document.querySelector('.main-inner-box').appendChild(newResourceElement);
                    jscolor.install('body'); 
                    sortTagsRow(newResourceElement);
                    sortResources(currentResourcesSort);
                    document.querySelector(`#resource-id-${newId}`).classList.remove('hidden');
                    document.querySelector(`#resource-id-${newId}`).classList.add('visible');
                    resourceCatDroppable([newResourceElement]);
                    createNewResourceToggle();
                };
            })
            .catch(error => {
                console.error('Error adding resource:', error);
                alert('Error adding resource');
            });

        }

    }


    

// EDIT RESOURCE
    function editResourceToggle(button, id){
        // console.log(button, id);
        const buttonName = button.getAttribute('name');
        const resource = document.querySelector(`#resource-id-${id}`);
        const heading = resource.querySelector('.resource-heading:not(.editable)');
        const headingEdit = resource.querySelector('.resource-heading.editable');
        const submitButton = resource.querySelector('.edit-submit-button');
        const cancelButton = resource.querySelector('.edit-cancel-button');
        //existing data
        const existingCover = heading.querySelector('img');
        let existingType = resource.getAttribute('data-type');
        let existingNumber = resource.getAttribute('data-number');
        const existingTypeClass = resource.classList.contains('book')
            ? 'book'
            : resource.classList.contains('article')
                ? 'article'
                : null;
        const existingTitle = heading.querySelector('.resource-title');
        const existingSubTitle = heading.querySelector('.resource-subtitle');
        const existingJournal = heading.querySelector('.resource-journal');
        const existingAuthors = heading.querySelector('.authors-content');
        const existingYear = heading.querySelector('.year-text');
        const existingPlace = heading.querySelector('.place-text');
        const existingUrl = resource.querySelector('.url-button');
        const comma = heading.querySelector('.comma');
        //new data
        const newCover = headingEdit.querySelector('img');
        const newType = headingEdit.querySelector('input[name="res-type"]:checked');
        const newNumber = headingEdit.querySelector(`#resource-${id}-isbn-doi`);
        const newTitle = headingEdit.querySelector('.resource-title.editable textarea');
        const newSubtitle = headingEdit.querySelector('.resource-subtitle.editable textarea');
        const newJournal = headingEdit.querySelector('.resource-journal.editable textarea');
        const newAuthors = headingEdit.querySelector('.author-text.editable textarea');
        const newYear = headingEdit.querySelector('.year-text.editable input');
        const newPlace = headingEdit.querySelector('.place-text.editable input');
        const newUrl = headingEdit.querySelector('.url-text.editable input');

        //clean up helper function
        function cleanUp () {
            newCover.setAttribute('src', existingCover.getAttribute('src')); 
            newCover.setAttribute('upload-flag', false);
            headingEdit.querySelector(`input[value="${existingType}"]`).checked = true; //revert 'type' radio input selection
            newNumber.value = existingNumber;
            newTitle.value = existingTitle.innerText;
            newSubtitle.value = existingSubTitle.innerText;
            newJournal.value = existingJournal.innerText;
            newAuthors.value = existingAuthors.innerText;
            newYear.value = existingYear.innerText;
            newPlace.value = existingPlace.innerText;
            newUrl.value = existingUrl.getAttribute('data-url');
            // console.log("submit and cancel button disabled");
            submitButton.disabled = true;
            cancelButton.disabled = true;
            heading.style.display = 'flex';
            headingEdit.style.display = 'none';
        }

        // check if submit
        if (buttonName == 'edit-resource-submit'){
            // console.log("edit submit");
            //check if required fields are not empty
            if (!newTitle.value || !newAuthors.value) {
                alert("title and authors fields can't be empty");
                return false;
            } else {
                let data = {
                    resource_id: id,
                    resource_title: newTitle.value,
                    resource_subtitle: newSubtitle.value,
                    journal: newJournal.value,
                    authors: newAuthors.value,
                    resource_type: newType.value,
                    reference_number: newNumber.value,
                    place: newPlace.value,
                    publication_year: newYear.value,
                    url: newUrl.value,
                };
                if (newCover.getAttribute('upload-flag') == 'true'){
                    data.cover_base64 = newCover.getAttribute('src');
                }
                //axios
                axios.put("/edit-resource", data)
                .then(response => {
                    if (response.data.success) {
                        // console.log("edit resource success", response.data);
                        //DOM operations
                        existingCover.setAttribute('src', newCover.getAttribute('src'));
                        resource.setAttribute('data-type', newType.value);
                        existingType = newType.value;
                        newType.checked = true;
                        resource.setAttribute('data-number', newNumber.value);
                        existingNumber = newNumber.value;
                        if (newType.value == 'ISBN') {
                            resource.classList.remove('article');
                            resource.classList.add('book');
                            resource.querySelector('.right-stripe').classList.remove('article');
                            resource.querySelector('.right-stripe').classList.add('book');
                        } else if (newType.value == 'DOI') {
                            resource.classList.remove('book');
                            resource.classList.add('article');
                            resource.querySelector('.right-stripe').classList.remove('book');
                            resource.querySelector('.right-stripe').classList.add('article');
                        }
                        existingTitle.innerText = newTitle.value;
                        existingSubTitle.innerText = newSubtitle.value;
                        existingJournal.innerText = newJournal.value;
                        existingAuthors.innerText = newAuthors.value;
                        existingYear.innerText = newYear.value;
                        existingPlace.innerText = newPlace.value;
                        if (existingYear.innerText && existingPlace.innerText) {
                            comma.innerText = ",";
                        } else {
                            comma.innerText = "";
                        }
                        existingUrl.setAttribute('data-url', newUrl.value);
                        if (newUrl.value) {
                            existingUrl.disabled = false;
                        } else {
                            existingUrl.disabled = true;
                        }
                        cleanUp();
                    };
                })
                .catch(error => {
                    console.error('Error editing resource:', error);
                    alert('Error editing resource');
                });

            }
        };

        //toggle buttons and visibility and cleanup
        if (heading.style.display == 'flex') {
            // console.log("submit and cancel button enabled");
            submitButton.disabled = false;
            cancelButton.disabled = false;
            heading.style.display = 'none';
            headingEdit.style.display = 'flex';
        } else if (buttonName != 'edit-resource-submit') {
            cleanUp();
        }

    }


    // listeners for cover upload
    // Function to attach the file input change listener to all .upload-cover elements within a given context
    function attachCoverUploadListeners(context = document) {
        // Select only those inputs that don't have a data attribute marking them as already processed
        const inputs = context.querySelectorAll('.upload-cover:not([data-listener-attached])');
        inputs.forEach(input => {
            input.addEventListener('change', handleCoverUploadChange);
            // Mark this input as having the event listener attached
            input.setAttribute('data-listener-attached', 'true');
        });
    }

    // The event handler that does the image processing, scaling, and cropping
    function handleCoverUploadChange(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = e => {
            const img = new Image();
            img.onload = () => {
                const targetWidth = 180;
                const targetHeight = 240;

                // Create a canvas with target dimensions
                const canvas = document.createElement('canvas');
                canvas.width = targetWidth;
                canvas.height = targetHeight;
                const ctx = canvas.getContext('2d');
                // Use high quality scaling settings
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';

                // Calculate scale factor to ensure the image covers the canvas entirely
                const scale = Math.max(targetWidth / img.width, targetHeight / img.height);
                const scaledWidth = img.width * scale;
                const scaledHeight = img.height * scale;

                // Calculate offsets to center the image so that cropping occurs evenly
                const offsetX = (targetWidth - scaledWidth) / 2;
                const offsetY = (targetHeight - scaledHeight) / 2;

                // Draw the image into the canvas with the computed dimensions and offsets
                ctx.drawImage(img, offsetX, offsetY, scaledWidth, scaledHeight);

                // Convert the canvas content to a data URL (using JPEG in this example)
                const dataUrl = canvas.toDataURL('image/jpeg');

                // Update the preview image (assuming .resource-cover > img is in the same container)
                const previewImg = event.target.parentElement.querySelector('.resource-cover img');
                if (previewImg) {
                    previewImg.src = dataUrl;
                    previewImg.setAttribute('upload-flag', true);
                }

                // Store the generated preview in a hidden input within the same form for final submission
                // const form = event.target.closest('form');
                // let hiddenInput = form.querySelector('input[name="coverPreview"]');
                // if (!hiddenInput) {
                //     hiddenInput = document.createElement('input');
                //     hiddenInput.type = 'hidden';
                //     hiddenInput.name = 'coverPreview';
                //     form.appendChild(hiddenInput);
                // }
                // hiddenInput.value = dataUrl;
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    }

    // Initial attachment on page load
    attachCoverUploadListeners();


// ADD NEW NOTE
    // rollout toggle
    function newNoteRolloutToggle(id) {
            document.getElementById("add-new-note-" + id).classList.remove("hidden");
            document.getElementById("add-new-note-" + id).classList.add("visible");
        }

    // Cancel new note form
    function cancelNewNote(id){
        document.getElementById(id).classList.add("hidden");
        document.getElementById(id).classList.remove("visible");
        document.getElementById(`tag-rollout-${id.slice(13)}`).classList.add("hidden-fast");
        document.getElementById(`tag-rollout-${id.slice(13)}`).classList.remove("visible-fast");
        document.getElementById(`tag-rollout-${id.slice(13)}`).classList.remove("active-rollout");
        clearSelectedTags();
    }

    // Resize text areas automatically
    const textareas = document.querySelectorAll('.new-note-text, .edit-note-textarea');
    for (let element of textareas) {
        element.addEventListener('input', function() {
            // Reset the height to allow shrinking if necessary
            this.style.height = 'auto';
            // Set the new height based on the scroll height
            this.style.height = (this.scrollHeight) + 'px';
        });
    };


// SELECT TAGS ROLLOUT, FOR NEW NOTE AND EXISTING NOTE
    let selectedTagIds = [];
    let selectedTagNames = [];
    let selectedTagColors = [];
    let selectedTagColorsInv = [];
    //helper function
    function clearSelectedTags(){
        const globalTagsCollection = document.querySelectorAll('.single-note-tags');
        globalTagsCollection.forEach(element =>{
            element.classList.remove('clicked');
            element.style.boxShadow = '';
        });
        const globalInputsCollection = document.querySelectorAll('input[name="selectedTagIds"], input[name="selectedTagsNames"], input[name="selectedTagsColors"], input[name="selectedTagsColorsInv"]');
        // console.log(globalInputsCollection);
        globalInputsCollection.forEach(element =>{
            element.setAttribute('value', '');
        });
    }

    function selectTagsRolloutToggle(button, resourceId, noteId) {
        // console.log(button);
        // prep all rollouts
        const allRollouts = document.querySelectorAll('.tag-rollout-drawer');
        allRollouts.forEach(element => {
            element.classList.remove('active-rollout');
        });
        // clear all buttons
        document.querySelectorAll('.note-tags-row .icon-button-tags').forEach(element => {
            element.classList.remove('clicked');
        });
        document.querySelectorAll('.new-note-tag-rollout-button .fa-square-caret-down').forEach(element =>{
            element.classList.remove('fa-square-caret-down');
            element.classList.add('fa-square-caret-right');
        });

        // clear ids array
        selectedTagIds.length = 0;       
        let rollout = undefined;
        //check if called from new note box or existing note
        if (!noteId) {
            rollout = document.getElementById('tag-rollout-' + resourceId);
            // Change icon in new note box
            let triangle = document.getElementById('triangle-icon-' + resourceId);
            if (triangle.classList.value === 'fa-solid fa-square-caret-right') {
                triangle.classList.value = 'fa-solid fa-square-caret-down';
            } else {
                triangle.classList.value = 'fa-solid fa-square-caret-right';
            }
        } else {
            //change button appearance
            button.classList.add('clicked');

            // clear all .clicked classes
            clearSelectedTags()

            rollout = document.getElementById('tag-rollout-' + resourceId + '-' + noteId);
            
            // get list of current tag ids
            const currentTags = document.getElementById('note-id-' + noteId).querySelectorAll('.note-tags-row > .single-note-tags');
            // console.log("current tags", currentTags);
            currentTags.forEach(element =>{
                selectedTagIds.push(element.getAttribute('data-id'));
            });
            // console.log("current tag ids: ", selectedTagIds);
        }
        rollout.classList.add("active-rollout"); //prevent from closing
        // close all other rollouts
        const otherRollouts = document.querySelectorAll('.tag-rollout-drawer:not(.active-rollout)');
        // console.log(otherRollouts);
        otherRollouts.forEach(element => {
            element.classList.add("hidden-fast");
            element.classList.remove("visible-fast");
        }) ;
        
        // Toggle tags rollouts
        if (rollout.classList.value == "tag-rollout-drawer hidden-fast active-rollout" || rollout.classList.value === '') {
            rollout.classList.remove("hidden-fast");
            rollout.classList.add("visible-fast");

            // Get the button's position and size relative to the viewport
            const buttonRect = button.getBoundingClientRect();
            // console.log(buttonRect);
            const popupRect = rollout.getBoundingClientRect();
            // console.log(popupRect);

            // Set the initial position of the popup below the button
            let topPosition = 32;
            let leftPosition = 0; 

            // Get the viewport dimensions
            const viewportHeight = window.innerHeight;
            // const viewportWidth = window.innerWidth;
            const viewportWidth = document.body.clientWidth;
            // console.log("viewport w", viewportWidth);

            // Check if the popup will overflow vertically
            if (buttonRect.bottom + popupRect.height > viewportHeight + window.scrollY) {
                // If it will, position the popup above the button
                topPosition = buttonRect.top + window.scrollY - popupRect.height;
            }

            // Check if the popup will overflow horizontally (if needed)
            if (buttonRect.left + popupRect.width > viewportWidth) {
                // If it will, adjust the popup to stay within the screen width
                leftPosition = viewportWidth - buttonRect.left - popupRect.width;
            }

            // Apply the adjusted positions
            rollout.style.top = `${topPosition}px`;
            rollout.style.left = `${leftPosition}px`;


            // Mark existing tags as clicked
            const allTagsCollection = rollout.querySelectorAll('.single-note-tags');
            Array.from(allTagsCollection).forEach(tag => {
                const tagId = tag.getAttribute('data-id');
                const tagColor = tag.getAttribute('data-color');
                if (selectedTagIds.includes(tagId)) {
                    tag.classList.add('clicked'); // Add the 'clicked' class
                    tag.style.boxShadow = `0 0 0 4px ${tagColor}`;
                }
            });
            // console.log(filteredTags);

        } else {
            button.classList.remove('clicked');
            document.querySelectorAll('.new-note-tag-rollout-button .fa-square-caret-down').forEach(element =>{
            element.classList.remove('fa-square-caret-down');
            element.classList.add('fa-square-caret-right');
            });
            rollout.classList.add("hidden-fast");
            rollout.classList.remove("visible-fast");
            rollout.classList.remove("active-rollout");
            selectedTagIds.length = 0;
            // console.log(selectedTagIds);
        }
    }


    // NEW NOTE ROLLOUT - SELECT TAGS

    function selectTag(element, resourceId, noteId) {
        const tagId = element.getAttribute('data-id');
        const tagName = element.getAttribute('data-name');
        const tagColor = element.getAttribute('data-color');
        const tagInvertColor = element.getAttribute('data-invert-color');
        const elementEditable = element.closest('.tag-rollout-drawer').querySelector(`.edit-tags-form .editable-tag-row[data-id='${tagId}']`);

        //Ids
        if (selectedTagIds.includes(tagId)) {
            selectedTagIds = selectedTagIds.filter(id => id !== tagId);
            element.classList.remove('clicked');
            element.style.boxShadow = '';
            elementEditable.classList.remove('clicked');
            elementEditable.style.boxShadow = '';
        } else {
            selectedTagIds.push(tagId);
            element.classList.add('clicked');
            element.style.boxShadow = `0 0 0 4px ${tagColor}`;
            elementEditable.classList.add('clicked');
            elementEditable.style.boxShadow = `0 0 0 4px ${tagColor}`;
        }
        //Names
        if (selectedTagNames.includes(tagName)) {
            selectedTagNames = selectedTagNames.filter(name => name !== tagName);
        } else {
            selectedTagNames.push(tagName);
        }
        //Colors
        if (selectedTagColors.includes(tagColor)) {
            selectedTagColors = selectedTagColors.filter(color => color !== tagColor);
        } else {
            selectedTagColors.push(tagColor);
        }
        //Inverted Colors
        if (selectedTagColorsInv.includes(tagInvertColor)) {
            selectedTagColorsInv = selectedTagColorsInv.filter(color => color !== tagInvertColor);
        } else {
            selectedTagColorsInv.push(tagInvertColor);
        }
        document.getElementById('selectedNewNoteTags-' + resourceId).value = selectedTagIds.join(',');
        document.getElementById('selectedNewNoteTagsNames-' + resourceId).value = selectedTagNames.join(',');
        document.getElementById('selectedNewNoteTagsColors-' + resourceId).value = selectedTagColors.join(',');
        document.getElementById('selectedNewNoteTagsColorsInv-' + resourceId).value = selectedTagColorsInv.join(',');
    }

// ADD NEW TAG - IN NEW NOTE AND EXISTING NOTE
    function addTag(resourceId, noteId) {

        let newTagRollout = "";
        let newTagInput = "";
        let newTagColorInput = "";
        // check if it's called from new note or existing note
        if (!noteId) {
            newTagRollout = document.querySelector(`#tag-rollout-${resourceId}`);
            newTagInput = newTagRollout.querySelector('.add-new-tag-input');
            newTagColor = newTagRollout.querySelector('.color-selector-button');
        } else {
            newTagRollout = document.querySelector(`#tag-rollout-${resourceId}-${noteId}`);
            newTagInput = newTagRollout.querySelector('.add-new-tag-input');
            newTagColor = newTagRollout.querySelector('.color-selector-button');
        }
        //check if name is provided
        if (!newTagInput.value) {
            return false;
        } else {
            // console.log("New tag name:",newTagInput.value);
            // console.log("New tag color picker element ", newTagColor);
            // console.log("New tag color: ", newTagColor.getAttribute('data-current-color'));
            const newCategoryColor = newTagColor.getAttribute('data-current-color');
            const newCategoryInvertedColor = invertColor(newCategoryColor);

            const data = {
                name: newTagInput.value,
                color: newCategoryColor
            };

            axios.post("/add-new-tag", data)
            .then(response => {
                if (response.data.success) {
                    //non editable tags rows
                    let allTagsRows = document.querySelectorAll('.tag-rollout-drawer > .all-tags-row');
                    // console.log(allTagsRows);
                    // this must go in a loop beacause the append child works only once per node
                    allTagsRows.forEach(element => {
                        let newCategoryElement = document.createElement('span');
                        newCategoryElement.classList.add('tag', 'single-note-tags', 'visible-horizontal');
                        newCategoryElement.setAttribute('data-id', response.data.id);
                        newCategoryElement.setAttribute('data-name', newTagInput.value);
                        newCategoryElement.setAttribute('data-color', newCategoryColor);
                        newCategoryElement.setAttribute('data-invert-color', newCategoryInvertedColor); 
                        newCategoryElement.style.backgroundColor = newCategoryColor;
                        newCategoryElement.style.color = newCategoryInvertedColor; 
                        newCategoryElement.style.borderColor = newCategoryInvertedColor; 
                        newCategoryElement.setAttribute('onclick', `selectTag(this, ${resourceId})`);
                        newCategoryElement.innerText = newTagInput.value;
                        // console.log("new tag element :", newCategoryElement);

                        // console.log(element);
                        element.appendChild(newCategoryElement);
                    });

                    //editable tags rows
                    let allTagsRowsEditable = document.querySelectorAll('.edit-tags-form > .all-tags-row');
                    allTagsRowsEditable.forEach(element => {
                        let newCategoryElement = document.createElement('div');
                        newCategoryElement.classList.add('editable-tag-row', 'tag', 'single-note-tags', 'visible-horizontal');
                        newCategoryElement.setAttribute('data-name', newTagInput.value);
                        newCategoryElement.setAttribute('data-id', response.data.id);                        
                        newCategoryElement.setAttribute('data-color', newCategoryColor);
                        newCategoryElement.setAttribute('data-invert-color', newCategoryInvertedColor); 
                        newCategoryElement.style.backgroundColor = newCategoryColor;
                        newCategoryElement.style.color = newCategoryInvertedColor; 
                        newCategoryElement.style.borderColor = newCategoryInvertedColor; 
                        newCategoryElement.innerHTML =`
                            <input type="text" oninput="this.size = this.value.length" class="tag editable" value="${newTagInput.value}" style="background-color:${newCategoryColor}; color: ${newCategoryInvertedColor};" size="${newTagInput.value.length}" >                                                           
                            <button 
                            class="icon-button color-selector-icon tooltip-container tag-color-${response.data.id}" 
                            data-jscolor="{value:'${newCategoryColor}'}"
                            type="button">
                            <span class="tooltip">change color</span>
                            </button>
                            <button class="delete-button icon-button tooltip-container delete-tag-${response.data.id}" type="button" onclick="showConfirmationPopup('${response.data.id}', '/delete-tag', ${resourceId}, null, null)">
                            <i class="fa-solid fa-trash" aria-hidden="true"></i><span class="tooltip">delete tag</span>
                            </button>
                        `;

                        element.appendChild(newCategoryElement);
                        
                    });
                    jscolor.install('body');
                    sortTagsRow();
                    //clear the input
                    newTagInput.value = ""
                }
            })
            .catch(error => {
                console.error('Error creating new tag:', error);
                alert('Error creating new tag');
            });


        }


    }

// ASSIGN TAGS TO NOTE
    function assignTags(button, resourceId, noteId){
        // console.log("Tags assignment client request. Note: ", noteId, " Tag Ids: ", selectedTagIds);

        const data = {
            resource_id: resourceId,
            note_id: noteId,
            tags_ids: selectedTagIds
        };
        axios.post("/assign-tags", data)
        .then(response =>{
            if (response.data.success) {
                // console.log(response.data.tags_obj);
                const noteTagsRow = document.querySelector(`#note-id-${noteId}`).querySelector('.note-tags-row');
                const oldTags = noteTagsRow.querySelectorAll(':scope > span');
                // console.log(oldTags);
                oldTags.forEach(element => {
                    element.remove();
                });
                // console.log("note tags row" ,noteTagsRow);
                response.data.tags_obj.forEach(tagObj =>{
                    // console.log(tagObj);
                    const newTagElement = document.createElement('span');
                    newTagElement.classList.add('single-note-tags');
                    newTagElement.setAttribute('data-id', tagObj.id);
                    newTagElement.setAttribute('data-name', tagObj.name);
                    newTagElement.setAttribute('data-color', tagObj.color);
                    newTagElement.setAttribute('data-invert-color', tagObj.invertColor);
                    newTagElement.style.backgroundColor = tagObj.color;
                    newTagElement.style.color = tagObj.invertColor;
                    newTagElement.style.borderColor = tagObj.invertColor;
                    newTagElement.innerText = tagObj.name;
                    noteTagsRow.appendChild(newTagElement);
                });

                sortTagsRow();
                
                //toggle off tags rollout and clear button
                const rollout = document.getElementById('tag-rollout-' + resourceId + '-' + noteId);
                rollout.classList.add("hidden-fast");
                rollout.classList.remove("visible-fast");
                rollout.classList.remove("active-rollout");
                document.querySelector(`#note-id-${noteId}`).querySelector('.icon-button-tags').classList.remove('clicked');
                selectedTagIds.length = 0;

            }
        })
        .catch(error => {
                console.error('Error assigning tags:', error);
                alert('Error assigning tags');
        });

    }


// EDIT AND DELETE TAGS
    // Buttons toggle
    function editTagsToggle(resourceId, noteId){
        let parentRollout = undefined;
        let tagsContainer = undefined;
        let editableTagsContainer = undefined;
        let form = undefined;
        //check if called from new note or existing note
        if (!noteId) {
            // dodac dla nowej notatki
            tagsContainer = document.querySelector(`#tag-container-${resourceId}`);
            editableTagsContainer = document.querySelector(`#edit-tag-container-${resourceId}`);
            parentRollout = document.querySelector(`#tag-rollout-${resourceId}`);
            // form = parentRollout.querySelector('.edit-tags-form');

        } else {
            tagsContainer = document.querySelector(`#tag-container-${resourceId}-${noteId}`);
            editableTagsContainer = document.querySelector(`#edit-tag-container-${resourceId}-${noteId}`);
            parentRollout = document.querySelector(`#tag-rollout-${resourceId}-${noteId}`);
            form = parentRollout.querySelector('.edit-tags-form');
        }
        //toggle
        if (tagsContainer.style.display == 'flex') {
            tagsContainer.style.display = 'none';
            editableTagsContainer.style.display = 'flex'
            parentRollout.querySelector('.edit-tags-submit-button').removeAttribute('disabled');
            parentRollout.querySelector('.edit-tags-cancel-button').removeAttribute('disabled');
            if (noteId) {
                parentRollout.querySelectorAll('.separator-2')[1].style.display = 'none';
                parentRollout.querySelector('.assign-tags-confirm').style.display = 'none';
            }

            parentRollout.querySelector('h4').innerText = 'Edit Note Tags';
        } else {
            tagsContainer.style.display = 'flex';
            editableTagsContainer.style.display = 'none'
            parentRollout.querySelector('.edit-tags-submit-button').disabled ='true';
            parentRollout.querySelector('.edit-tags-cancel-button').disabled ='true';
            parentRollout.querySelector('h4').innerText = 'Assign Note Tags';
            if (noteId) {
                parentRollout.querySelectorAll('.separator-2')[1].style.display = 'block';
                parentRollout.querySelector('.assign-tags-confirm').style.display = 'inline-block';
                form.reset();
            }

        }
    }

    // EDIT TAGS SUBMIT
    function editTagsSubmit (button){
        const inputs = button.closest('.tag-rollout-drawer').querySelector('.edit-tags-form').querySelectorAll('input');
        const form = button.closest('.tag-rollout-drawer').querySelector('.edit-tags-form');
        const parentRollout = button.closest('.tag-rollout-drawer');
        const tagsContainer = parentRollout.querySelector(':scope > .all-tags-row');
        const editableTagsContainer = parentRollout.querySelector('.edit-tags-form > .all-tags-row');
        let dataUpdate = [];
        inputs.forEach(input =>{
            const tagObj = {
                tag_id: Number(input.closest('.editable-tag-row').getAttribute('data-id')),
                tag_name: input.value,
                tag_color: input.closest('.editable-tag-row').getAttribute('data-color'),
                tag_inverted_color: invertColor(input.closest('.editable-tag-row').getAttribute('data-color'))
            };
            dataUpdate.push(tagObj);
        });
        // console.log("All tags updated list", dataUpdate);
        axios.put("/edit-tags", dataUpdate)
        .then((response) => {
            if (response.data.success) {
                console.log("response success");
                //update DOM tag elements by each tag id
                const singleNoteTags = [...document.querySelectorAll('.single-note-tags')];
                dataUpdate.forEach(tag =>{
                    const elementMatch = singleNoteTags.filter((prop) => prop.getAttribute('data-id') == tag.tag_id);
                    // console.log("Tag id:", tag.tag_id, "matches: ", elementMatch);
                    elementMatch.forEach(element => {
                        element.setAttribute('data-name', tag.tag_name);
                        element.setAttribute('data-color', tag.tag_color);
                        element.setAttribute('data-invert-color', tag.tag_inverted_color);
                        element.style.backgroundColor = tag.tag_color;
                        element.style.color = tag.tag_inverted_color;
                        element.style.borderColor = tag.tag_inverted_color;
                        if (element.nodeName == "SPAN") {
                            element.innerText = tag.tag_name;
                        }
                        if (element.classList.contains('editable-tag-row')) {
                            const inputElement = element.querySelector('input');
                            const buttonElement = element.querySelector('.color-selector-icon');
                            inputElement.setAttribute('value', tag.tag_name);
                            inputElement.style.color = tag.tag_inverted_color;
                            inputElement.style.backgroundColor = tag.tag_color;
                            inputElement.style.borderColor = tag.tag_inverted_color;
                            inputElement.size = inputElement.value.length;
                            buttonElement.setAttribute('data-current-color', tag.tag_color);
                            buttonElement.setAttribute('data-jscolor', `{value:'${tag.tag_color}'}`);
                            buttonElement.style.backgroundImage = 'none';                            
                        }
                        if (element.classList.contains('clicked')) {
                            element.style.boxShadow = `${tag.tag_color} 0px 0px 0px 4px`;
                        }
                    });
                });
                sortTagsRow();
                //close rollout
                tagsContainer.style.display = 'flex';
                editableTagsContainer.style.display = 'none'
                parentRollout.querySelector('.edit-tags-submit-button').disabled ='true';
                parentRollout.querySelector('.edit-tags-cancel-button').disabled ='true';
                try {
                    parentRollout.querySelectorAll('.separator-2')[1].style.display = 'block';
                    parentRollout.querySelector('.assign-tags-confirm').style.display = 'inline-block';
                } catch (error) {
                    
                }
                parentRollout.querySelector('h4').innerText = 'Assign Note Tags';
            }
        })
        .catch((error) => {
            console.error("Error editing tags", error);
        });
    }



// NOWE SUBMIT NOTE Z AXIOS i RES.JSON
    function submitNewNote(formId) {
        // Prevent default form submission
        event.preventDefault();

        // Get the form element
        const form = document.getElementById(formId);
        const formObject = formToObject(formId);
        console.log("New note dataa: ", formObject);

        // Send the data using axios
        axios.post('/add-note', formObject)
        .then((response) => {
            if (response.data.success) {
                const newNote = response.data.newNote;
                console.log("response new note",newNote);
                // console.log("response", response.data);

                // Create a new note DOM element
                const newNoteElement = document.createElement('div');
                newNoteElement.classList.add('single-note-item', 'deletable-item', 'hidden');
                newNoteElement.setAttribute('id', `note-id-${newNote.note_id}`);

                // create tags row
                let tagsRowHtml = "";
                for (const tag of newNote.selectedTags) {
                    tagsRowHtml = tagsRowHtml.concat(`<span class="single-note-tags" data-id="${tag.id}" data-name="${tag.name}" data-color="${tag.color}" data-invert-color="${tag.invertColor}" style="background-color: ${tag.color}; color: ${tag.invertColor}; border-color: ${tag.invertColor}">${tag.name}</span>`);
                }
                // copy all tags row for the assign tags rollout
                const newAllTagsRow = document.querySelector(`#tag-container-${newNote.resource_id}`).cloneNode(true);
                const newAllTagsRowEditable = document.querySelector(`#edit-tag-container-${newNote.resource_id}`).cloneNode(true);
                newAllTagsRow.id = `tag-container-${newNote.resource_id}-${newNote.note_id}`;
                newAllTagsRowEditable.id = `edit-tag-container-${newNote.resource_id}-${newNote.note_id}`;

                // empty fields check
                let pagesHtml = ""
                if (newNote.target_pages) {pagesHtml = `Pages: ${newNote.target_pages}`}
                let linkHtml = ""
                if (newNote.target_object) {linkHtml = `Link: <a href="${newNote.target_object}" rel="noopener noreferrer" target="_blank">${newNote.target_object}</a>`}
                
                newNoteElement.innerHTML = `
                <div class="note-heading-row">
                    <div class="note-date-del-edit-row">
                        <button 
                            class="icon-button tooltip-container" 
                            type="edit" 
                            name="edit-note" 
                            onclick="editNoteToggle(this, ${newNote.note_id})">
                            <i class="fa-solid fa-file-pen"></i><span class="tooltip">edit note</span>
                        </button>
                        <button 
                            disabled
                            class="icon-button tooltip-container edit-submit-button"
                            type="button"
                            name="edit-note-submit" 
                            onclick="editNoteToggle(this, ${newNote.note_id})">
                            <i class="fa-solid fa-floppy-disk"></i><span class="tooltip">save changes</span>
                        </button>
                        <button 
                            disabled
                            class="icon-button tooltip-container edit-cancel-button" 
                            type="button" 
                            name="edit-note-cancel" 
                            onclick="editNoteToggle(this, ${newNote.note_id})">
                            <i class="fa-solid fa-rotate-left"></i><span class="tooltip">discard changes</span>
                        </button>
                        <button 
                            class="icon-button tooltip-container generate-citation-button" 
                            type="button" 
                            name="generate-citation" 
                            onclick="generateCitation('${newNote.note_id}')">
                        <i class="fa-solid fa-quote-right"></i><span class="tooltip">generate citation</span>
                        </button>

                        <button class="delete-button icon-button tooltip-container" id="delete-note-${newNote.note_id}" type="button" onclick="showConfirmationPopup('${newNote.note_id}', '/delete-note', '${newNote.resource_id}', 'note-id-${newNote.note_id}', null)">
                            <i class="fa-solid fa-trash" aria-hidden="true"></i><span class="tooltip">delete note</span>
                        </button>
                        <p class="note-date" value="date" id="note-${newNote.note_id}-date"> ${newNote.formattedDate}</p>

                    </div>
                    <!-- NOTE HEADING: TAGS -->
                    <div class="note-tags-row">
                        <button class="icon-button-tags tooltip-container" type="add" name="add-tag" onclick="selectTagsRolloutToggle(this, '${newNote.resource_id}', '${newNote.note_id}')">+<span class="tooltip">assign note tags</span></button>
                        <div id="tag-rollout-${newNote.resource_id}-${newNote.note_id}" class="tag-rollout-drawer hidden-fast">
                            <div class="heading-with-buttons">
                                <h4>Assign Note Tags</h4>
                                <div>
                                    <button class="icon-button tooltip-container edit-tags-toggle-button" type="edit" name="edit-tags-toggle" onclick="editTagsToggle('${newNote.resource_id}', '${newNote.note_id}')">
                                    <i class="fa-solid fa-file-pen" aria-hidden="true"></i><span class="tooltip">edit tags</span>
                                    </button>
                                    <button class="icon-button tooltip-container edit-tags-submit-button" type="submit" name="edit-tags-submit" onclick="editTagsSubmit(this)" disabled>
                                    <i class="fa-solid fa-floppy-disk" aria-hidden="true"></i><span class="tooltip">save changes</span>
                                    </button>
                                    <button class="icon-button tooltip-container edit-tags-cancel-button" type="reset" name="edit-tags-cancel" onclick="editTagsToggle('${newNote.resource_id}', '${newNote.note_id}')" disabled>
                                    <i class="fa-solid fa-rotate-left" aria-hidden="true"></i><span class="tooltip">discard changes</span>
                                    </button>
                                </div>
                            </div>
                            <div class="separator-2"></div>
                            ${newAllTagsRow.outerHTML}
                            <form class="edit-tags-form">
                                ${newAllTagsRowEditable.outerHTML}
                            </form>
                            <div class="add-new-tag-miniform">
                                <input class="add-new-tag-input" type="text" placeholder="New tag name..." />
                                <button class="color-selector-button jscolor" data-jscolor="{value:'#5ED8FF'}" >color</button>
                                <button class="text-button" type="button" onclick="addTag(${newNote.resource_id}, ${newNote.note_id})">Add New Tag</button>
                            </div>
                            <div class="separator-2" style="display: block;"></div>
                            <div>
                                <button class="text-button assign-tags-confirm" type="button" onclick="assignTags(this, ${Number(newNote.resource_id)}, ${Number(newNote.note_id)})" style="display: inline-block;">Confirm Tags</button>
                            </div>
                        </div>
                        ${tagsRowHtml}
                    </div>
                </div>

                <!-- NOTE TEXT -->
                <div class="single-note-text" id="note-text-${newNote.note_id}">
                    
                    <p class="note-text-area" id="note-text-area-${newNote.note_id}" style="display: flex;">${newNote.note_text}</p>
                    <textarea class="edit-note-textarea" id="note-text-area-edit-${newNote.note_id}" style="display: none;">${newNote.note_text}</textarea>
                    <div class="note-bottom-row" style="display: flex;">
                        <span class="single-note-targets target-link" id="note-target-object-${newNote.note_id}">
                            ${linkHtml}
                        </span>
                        <span class="single-note-targets target-pages" id="note-target-pages-${newNote.note_id}" data-content="${newNote.target_pages}">
                            ${pagesHtml}
                        </span>
                    </div>
                    <div class="note-bottom-row" style="display: none;">
                        <span class="single-note-targets target-link" id="note-target-object-edit-${newNote.note_id}">
                                Link: <input class="input-link" type="text" value="${newNote.target_object}">
                        </span>
                        <span class="single-note-targets target-pages" id="note-target-pages-edit-${newNote.note_id}">
                                Pages: <input class="input-pages" type="text" value="${newNote.target_pages}">
                        </span>
                    </div>

                </div>
                `;
                // Append the new note element to the container
                document.getElementById('notesbox-' + newNote.resource_id ).appendChild(newNoteElement);
                jscolor.install('body'); // it's needed to initialize the newly created color picker
                sortTagsRow();
                sortNotesToggle();
                // fade in animation
                document.getElementById(`note-id-${newNote.note_id}`).classList.remove("hidden");
                document.getElementById(`note-id-${newNote.note_id}`).classList.add("visible");

                form.reset();
                document.getElementById(formId).classList.add("hidden")
                document.getElementById(formId).classList.remove("visible")

            } else {
                alert('Error adding note');
            }
        })
        .catch((error) => {
            console.error('Error posting note:', error);
            alert('An error occurred while posting the note.');
        });
    }


//EDIT NOTE TOGGLE WITH AXIOS ROUTE
    function editNoteToggle(button, id){
        const noteTextContainerChildren = [...document.querySelector(`#note-text-${id}`).children];
        const submitButton = document.querySelector(`#note-id-${id} .edit-submit-button`);
        const cancelButton = document.querySelector(`#note-id-${id} .edit-cancel-button`);
        const textArea = document.querySelector(`#note-text-area-${id}`);
        const textAreaEdit = document.querySelector(`#note-text-area-edit-${id}`);
        const link = document.querySelector(`#note-target-object-${id}`);
        const linkEdit = document.querySelector(`#note-target-object-edit-${id}`);
        const pages = document.querySelector(`#note-target-pages-${id}`);
        const pagesEdit = document.querySelector(`#note-target-pages-edit-${id}`);
        const resource = document.querySelector(`#note-id-${id}`).closest('.user-resource');
        // console.log(noteTextContainerChildren);

        //check if submit
        if (button.getAttribute('name') == "edit-note-submit") {
            // console.log("new text value", textAreaEdit.value);
            //check if not empty
            if (!textAreaEdit.value) {
                alert("Text field empty!");
                return false;
            } else {
                const data = {
                    note_id: id,
                    note_text: textAreaEdit.value,
                    note_link: linkEdit.querySelector('input').value,
                    note_pages: pagesEdit.querySelector('input').value
                };
                console.log("data to send: ",data);
                //axios
                axios.put("/edit-note", data)
                .then(response => {
                    if (response.data.success) {
                        console.log("response ", response.data);
                        //response and build html
                        textArea.innerText = textAreaEdit.value;
                        document.querySelector(`#note-${id}-date`).innerText = response.data.resultData.formattedDate;
                        //check if new link field is not empty
                        if (linkEdit.querySelector('input').value) {
                            // console.log("new input has value: ", linkEdit.querySelector('input').value);
                            //check if the <a> exists
                            if (link.querySelector('a')) {
                                // console.log("a exists");
                                // console.log(link.innerHTML);
                                link.querySelector('a').innerText = linkEdit.querySelector('input').value;
                                link.querySelector('a').setAttribute('href', linkEdit.querySelector('input').value);
                            } else {
                                // console.log("a not exist, create try");
                                document.querySelector(`#note-target-object-${id}`).innerHTML = `
                                    Link:
                                    <a href="${linkEdit.querySelector('input').value}" rel="noopener noreferrer" target="_blank">${linkEdit.querySelector('input').value}</a>
                                `;
                            }
                        } else {
                            // remove <a> if exists
                            // console.log("new link is empty. clearing old one.");
                            document.querySelector(`#note-target-object-${id}`).innerHTML = " ";
                        }

                        //check if new pages field is not empty
                        if (pagesEdit.querySelector('input').value) {
                            // console.log("new input has value: ", pagesEdit.querySelector('input').value);
                            pages.innerText = `Pages: ${pagesEdit.querySelector('input').value}`;
                        } else {
                            // remove pages if exist
                            // console.log("new pages are empty. clearing old.");
                            pages.innerText = "";
                        }
                        sortNotesToggle('date-descending', resource);
                    }
                })
                .catch(error => {
                    console.error('Error editing note:', error);
                    alert('Error editing note');
                });
            }
        }

        //toggle buttons
        if (textArea.style.display == 'flex') {
            // console.log("submit and cancel button enabled");
            submitButton.disabled = false;
            cancelButton.disabled = false;
            //set height of textarea input to fit existing text
            textAreaEdit.style.height = (textAreaEdit.scrollHeight) + 'px';
        } else {
            // console.log("submit and cancel button disabled");
            submitButton.disabled = true;
            cancelButton.disabled = true;
        }
        // toggle elements visibility
        noteTextContainerChildren.forEach(child => {
            if (child.style.display == 'flex') {
                child.style.display = 'none';
            } else {
                child.style.display = 'flex';
            }
        });

        //check if cancel - moved to end for the sake of not loosing \n line breaks
        if (button.getAttribute('name') == "edit-note-cancel") {
            textAreaEdit.value = textArea.innerText;
            linkEdit.querySelector('input').value = link.querySelector('a')?.innerText ?? null;
            pagesEdit.querySelector('input').value = pages.getAttribute('data-content') ?? null;
        }
    }





</script>

<!-- DELETE ITEMS - GLOBAL FUNCTIONS -->
<script>
    // Removal popup
    function showRemovePopup() {
        document.getElementById('remove-popup').style.display = 'flex';
    }
    function hideRemovePopup() {
        document.getElementById('remove-popup').style.display = 'none';
    }

    // Function to show confirmation popup and set the item ID, route, resource_id, type
    function showConfirmationPopup(itemId, route, resourceId, itemDOMid, additionalDomIdToDelete) {
        // Set the hidden item_id for deletion in the form dynamically
        document.querySelector('input[name="delete_item_id"]').value = itemId;
        // Set the hidden item_type for deletion in the form dynamically
        document.querySelector('input[name="delete_item_DOMid"]').value = itemDOMid;
        document.querySelector('input[name="delete_item_DOMid_additional"]').value = additionalDomIdToDelete;
        // Set the hidden resource_id for the item in the form dynamically
        document.querySelector('input[name="delete_resource_id"]').value = resourceId;
        // Set the action (route) dynamically
        // document.getElementById('delete-form').action = route;
        document.querySelector('input[name="delete_route"]').value = route;
        // Show the confirmation popup
        document.getElementById('confirmation-popup').style.display = 'flex';
    }

// Function to handle cancellation
function cancelDelete() {
    // Hide the confirmation popup without submitting the form
    document.getElementById('confirmation-popup').style.display = 'none';
}

// Delete Item (DELETE request using Axios)
// Function to handle deletion when user confirms
function confirmDelete() {
    // Hide the confirmation popup
    document.getElementById('confirmation-popup').style.display = 'none';

    const itemDomId = document.getElementById('delete-form').delete_item_DOMid.value;
    const additionalItemDomId = document.getElementById('delete-form').delete_item_DOMid_additional.value;
    const itemElement = document.getElementById(itemDomId);
    const additionalItemElement = document.getElementById(additionalItemDomId);
    const itemId = document.getElementById('delete-form').delete_item_id.value;
    const itemResourceId = document.getElementById('delete-form').delete_resource_id.value;
    const route = document.getElementById('delete-form').delete_route.value;

    // console.log("FE Delete request sent: ", itemDomId, additionalItemDomId, itemId, itemResourceId, route);
    
    // do data bedzie mozna dodawac kolejne opcje jezeli beda potrzebne, np. note_id przy kasowaniu tagow
    const data = {
        resource_id: itemResourceId, 
        item_id: itemId
    };

    // axios route
    axios.post(route, data)
    .then(response => {
        if (response.data.success) {
            // result depending on route
            if (route == "/delete-category") { //animation and delete for categories
                itemElement.classList.add('fade-out');
                additionalItemElement.classList.add("hidden-horizontal");
                additionalItemElement.classList.remove("visible-horizontal");
                const categoriesOnResources = document.querySelectorAll(`.resource-with-category-${itemId}`);
                categoriesOnResources.forEach(element => element.classList.add("hidden-horizontal"));
                categoriesOnResources.forEach(element => element.classList.remove("visible-horizontal"));
                setTimeout(() => {
                    itemElement.remove();
                    additionalItemElement.remove();
                    document.querySelectorAll(`.resource-with-category-${itemId}`).forEach(element => element.remove());
                }, 500);
            } else if (route == "/delete-note") { //animation and delete for notes
                itemElement.classList.add('fade-out');
                setTimeout(() => {
                    itemElement.remove();
                }, 300);
            } else if (route == "/delete-tag") { //animation and delete for tags
                const tagElements = document.querySelectorAll(`.single-note-tags[data-id="${itemId}"]`);
                // const tagElements = [...allTagElements].filter((tag) => tag.getAttribute('data-id') == itemId);
                // console.log(tagElements);
                tagElements.forEach(element => {
                    element.classList.add("fade-out");
                    element.classList.add("hidden-horizontal");
                    element.classList.remove("visible-horizontal");
                });
                setTimeout(() => {
                    tagElements.forEach(element => {
                        element.remove();
                    });
                }, 500);
            } else if (route == "/delete-resource") { //animation and delete for notes
                itemElement.classList.add('fade-out');
                setTimeout(() => {
                    itemElement.remove();
                }, 300);
            }
        }
    })
    .catch(error => {
        console.error('Error deleting item:', error);
        alert('Error deleting item');
    });

}


//ADD (DRAG) CATEGORY TO A RESOURCE
    function catDraggable(elementsArray) {
        // event listeners for draggable categories
        elementsArray.forEach(item => {
            // drag start
            item.addEventListener('dragstart', (event) => {
                event.target.classList.add('dragging');
                event.dataTransfer.clearData();
                const categoryData = {
                    id: item.getAttribute('data-id'),
                    name: item.getAttribute('data-name'),
                    draggable_cat_to_book: true
                };
                // console.log("category data send: ", categoryData);
                event.dataTransfer.setData("text/plain", JSON.stringify(categoryData) );

                //remove pointer events from resource children
                document.querySelectorAll('.user-resource').forEach(resource => {
                    let children = resource.querySelectorAll('*');
                    children.forEach(child => {
                        child.style.pointerEvents = 'none';
                    });
                });
            });
            // drag end
            item.addEventListener('dragend', (event) => {
                event.target.classList.remove('dragging');
                //restore pointer events for resource children
                document.querySelectorAll('.user-resource').forEach(item => {
                    let children = item.querySelectorAll('*');
                    children.forEach(child => {
                        child.style.pointerEvents = '';
                    });
                });
                // console.log("drag ended");
            });
        });
    }
    // call on page load
    catDraggable(document.getElementById('categories-list').querySelectorAll('.categories-item'));

    // event listeners for resources
    function resourceCatDroppable(resourceElementsArray) {
        // console.log(resourceElementsArray);
        resourceElementsArray.forEach(item => {
            item.addEventListener('dragenter', (event) => {
                event.preventDefault();
                event.target.classList.add('dragover');
                // console.log("drag started");
            });
            item.addEventListener('dragleave', (event) => {
                event.preventDefault();
                event.target.classList.remove('dragover');
                // console.log("drag ended");
            });

            // to allow the drop by preventing the default behavior during dragover
            item.addEventListener('dragover', (event) => {
                event.preventDefault();  // This allows the drop event to be triggered
            });

            // drop
            item.addEventListener('drop', (event) => {
                event.preventDefault();
                const dataReceived = JSON.parse(event.dataTransfer.getData("text/plain"));
                dataReceived.resource_id = item.id.slice(12);
                // console.log("Data received", dataReceived);
                addCategoryToResource(dataReceived);
                event.target.classList.remove('dragover');
            });
        });
    }
    // call on page load
    resourceCatDroppable(document.querySelectorAll('.user-resource'));

    //AFTER DROP FUNCTION WITH AXIOS ROUTE
    function addCategoryToResource(droppedData) {
        // console.log("dropped data:", droppedData);
        const selectedResource = document.querySelector(`#resource-id-${droppedData.resource_id}`)
        // console.log(selectedResource);
        let selectedResourceCategories = selectedResource.querySelector('.resource-categories-row');

        //check if the category is already present or if it's a proper draggable object
        if (selectedResourceCategories.querySelector(`#resource-${droppedData.resource_id}-cat-${droppedData.id}`) || !droppedData.draggable_cat_to_book) {
            return false;
        } else {
            //axios route
            axios.post("/assign-category", droppedData)
            .then(response => {
                if (response.data.success) {
                    // build html span element
                    let newHtmlElement = document.createElement('span');
                    newHtmlElement.classList.add('single-category', `resource-with-category-${droppedData.id}`, 'hidden-horizontal');
                    newHtmlElement.setAttribute('id', `resource-${droppedData.resource_id}-cat-${droppedData.id}`);
                    newHtmlElement.setAttribute('data-id', droppedData.id);
                    newHtmlElement.setAttribute('draggable', 'true');
                    newHtmlElement.innerText = droppedData.name;
                    addResourceCatListeners(newHtmlElement, selectedResource);
                    selectedResourceCategories.appendChild(newHtmlElement);
                    sortCategoriesList();
                    setTimeout(() => {
                        document.getElementById(`resource-${droppedData.resource_id}-cat-${droppedData.id}`).classList.remove("hidden-horizontal")
                        document.getElementById(`resource-${droppedData.resource_id}-cat-${droppedData.id}`).classList.add("visible-horizontal")
                    }, 10); //time out żeby się animacje odpalały
                }
            })
            .catch(error => {
                console.error('Error assigning category:', error);
                alert('Error assigning category');
            });
        }
    }


//REMOVE (DRAG) CATEGORY FROM RESOURCE NOWA WERSJA Z FUNKCJA ZEWNETRZNA
    // event listeners for draggable categories
    const bucketButton = document.querySelector('#remove-item-bucket');
    // add listeners to one category function - needs calling elsewere
    function addResourceCatListeners (categoryObj, resourceObj){
        const resourcesDropTargets = document.querySelectorAll('.user-resource');
        //drag start
        categoryObj.addEventListener('dragstart', (event) => {
            bucketButton.style.pointerEvents = 'auto'; //to prevent the hidden popup from interfering with category dragging
            event.target.classList.add('draggingdelete');
            event.dataTransfer.clearData();
            const categoryData = {
                resource_id: resourceObj.getAttribute('data-id'),
                category_id: categoryObj.getAttribute('data-id'),
                draggable_cat_to_trash: true
            };
            // console.log("category data: ", categoryData);
            event.dataTransfer.setData("text/plain", JSON.stringify(categoryData) );

            //remove pointer events from resource children
            resourcesDropTargets.forEach(resource => {
                resource.style.pointerEvents = 'none';  
                let children = resource.querySelectorAll('*:not(.single-category)');
                children.forEach(child => {
                    child.style.pointerEvents = 'none';
                });
            });
            showRemovePopup();
        });

        //drag end
        categoryObj.addEventListener('dragend', (event) => {
            bucketButton.style.pointerEvents = ''; //restore popup pointer events
            event.target.classList.remove('draggingdelete');
            //restore pointer events for resource children
            resourcesDropTargets.forEach(resource => {
                resource.style.pointerEvents = '';
                let children = resource.querySelectorAll('*:not(.single-category)');
                children.forEach(child => {
                    child.style.pointerEvents = '';
                });
            });
            hideRemovePopup();
        });

    }

    // on page load assign listeners to each category item on each resource
    document.querySelectorAll('.user-resource').forEach(resource => {
        let resourceCategories = resource.querySelectorAll('.single-category');
        resourceCategories.forEach(category =>{
            // console.log(category);
            addResourceCatListeners(category, resource);
        });
    });

    //BUCKET LISTENERS

    bucketButton.addEventListener('dragenter', (event) => {
        event.preventDefault();
        event.target.classList.add('dragover');
        // console.log("drag started");
    });
    bucketButton.addEventListener('dragleave', (event) => {
        event.preventDefault();
        event.target.classList.remove('dragover');
        // console.log("drag ended");
    });

    // to allow the drop by preventing the default behavior during dragover
    bucketButton.addEventListener('dragover', (event) => {
        event.preventDefault();  // This allows the drop event to be triggered
    });
    // drop
    bucketButton.addEventListener('drop', (event) => {
        event.preventDefault();
        const dataReceived = JSON.parse(event.dataTransfer.getData("text/plain"));
        // console.log("Data received", dataReceived);
        removeCategoryFromResource(dataReceived);
        event.target.classList.remove('dragover');
    });

    //AFTER DROP FUNCTION WITH AXIOS ROUTE
    function removeCategoryFromResource(droppedData) {
        // console.log("dropped data:", droppedData);
        let itemToRemove = document.querySelector(`#resource-${droppedData.resource_id}-cat-${droppedData.category_id}`)

        //check if it's a proper draggable object
        if (!droppedData.draggable_cat_to_trash) {
            return false;
        } else {
            //axios route
            axios.post("/strip-category", droppedData)
            .then(response => {
                if (response.data.success) {
                    // console.log("response success");
                    itemToRemove.classList.add("hidden-horizontal");
                    itemToRemove.classList.remove("visible-horizontal");
                    setTimeout(() => {
                        itemToRemove.remove();
                        sortCategoriesList();
                    }, 500); //time out żeby się animacje odpalały
                }
            })
            .catch(error => {
                console.error('Error assigning category:', error);
                alert('Error assigning category');
            });
        }
    }

</script>

</body>
</html>